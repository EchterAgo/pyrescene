Content-Type: multipart/related; start=<op.mhtml.1341498640028.d377d824152ea843@192.168.0.177>; boundary=----------cpWK6SNTBdR6XrFMatzjTO
Content-Location: http://www.tactilemedia.com/info/MCI_Control_Info.html
Subject: =?utf-8?Q?Multimedia=20Programming=20Interface=20and=20Data=20Specifications=201.0?=
MIME-Version: 1.0

------------cpWK6SNTBdR6XrFMatzjTO
Content-Disposition: inline; filename=MCI_Control_Info.html
Content-Type: text/html; name=MCI_Control_Info.html
Content-ID: <op.mhtml.1341498640028.d377d824152ea843@192.168.0.177>
Content-Location: http://www.tactilemedia.com/info/MCI_Control_Info.html
Content-Transfer-Encoding: 8bit

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML><HEAD><TITLE>Multimedia Programming Interface and Data Specifications 1.0</TITLE></HEAD>
<BODY BGCOLOR=#FFFFFF>How to control internal/external hardware using Microsoft's Media Control Interface.<br>
		See the following links for specific code/commands:
		<p><FONT FACE="Arial" SIZE=2><a href="#system">MCI System Commands</a><br>
				<a href="#required">Required Commands</a><br>
				<a href="#basic">Basic Commands</a><br>
				<a href="#cdaudio">CD Audio (Redbook)</a><br>
				<a href="#midi">MIDI Commands</a><br>
				<a href="#videodisc">Videodisc Commands</a><br>
				<a href="#audio">Waveform Audio Commands</a><br>
			</FONT></p>
		<hr>
		<p>
Multimedia Programming Interface <BR>
			
and Data Specifications 1.0</p>
		<P><b>Issued as a joint design by IBM Corporation and Microsoft Corporation</b>
			<P><b>
August 1991</b>
			<P>
This document describes the programming interfaces and data specifications for multimedia that are common to both OS/2 and Windows environments. These specifications may be enhanced to incorporate new technologies or modified based on customer feedback and, as such, specifications incorporated into any final product may vary.<P>
Microsoft is a registered trademark, and Windows is a trademark of Microsoft Corp.<P>
IBM and OS/2 are registered trademarks of International Business Machines Corporation.<P>
<b>Contents</b><P>
<OL>
		<LI>Contents</OL><P>
<b>Chapter </b><P>
<h1>Overview of Multimedia Specifications</h1><P>
This document describes the file format and control interface specifications for multimedia. These specifications allow developers to use common file format and device control interfaces.<P>
<h2>Resource Interchange File Format</h2><P>
The Resource Interchange File Format (RIFF), a tagged file structure, is a general specification upon which many file formats can be defined. The main advantage of RIFF is its extensibility; file formats based on RIFF can be future-proofed, as format changes can be ignored by existing applications.<P>
The RIFF file format is suitable for the following multimedia tasks:<P>
* Playing back multimedia data<P>
* Recording multimedia data<P>
* Exchanging multimedia data between applications and across platforms<P>
Chapter 2, "Resource Interchange File Format," describes the RIFF format.<P>
<h2>Multimedia File Formats</h2><P>
A number of RIFF-based and non-RIFF file formats have been defined for the storage of multimedia data. Chapter 3, "Multimedia File Formats," describes the following file formats:<P>
* Bundle File Format<P>
* Device-Independent Bitmap (DIB) and RIFF DIB file formats<P>
* Musical Instrument Digital Interface (MIDI) and RIFF MIDI file formats<P>
* Palette File Format<P>
* Rich Text File Format<P>
* Waveform Audio File Format<P>
<h2>Media Control Interface</h2><P>
The Media Control Interface (MCI) is a high-level control mechanism that provides a device-independent interface to multimedia devices and resource files.<P>
The Media Control Interface (MCI) provides a command set for playing and recording multimedia devices and resource files. Developers creating multimedia applications are encouraged to use this high-level command interface rather than the low-level functions specific to each platform. The MCI command set acts as a platform-independent layer that sits between multimedia applications and the underlying system software. <P>
The MCI command set is extensible in two ways:<P>
* Developers can incorporate new multimedia devices and file formats in the MCI command set by creating new MCI drivers to interpret the commands.<P>
* New commands and command options can be added to support special features or functions required by new multimedia devices or file formats.<P>
Using MCI, an application can control multimedia devices using simple command strings like open, play, and close. The MCI command strings provide a generic interface to different multimedia devices, reducing the number of commands a developer needs to learn. A multimedia application might even accept MCI commands from an end user and pass them unchanged to the MCI driver, which parses the command and performs the appropriate action.<P>
Chapter 3, "Media Control Interface," describes MCI and its command set in detail.<P>
<h2>Registering Multimedia Formats</h2><P>
This document discusses several multimedia codes and formats that require registration. These multimedia elements include the following:<P>
* Compression techniques<P>
* RIFF form types, chunk IDs, and list types<P>
* Compound-file usage codes<P>
* Waveform audio format codes<P>
To register these multimedia elements, request a <i>Multimedia Developer Registration Kit</i> from the following group:RIFF forms;registering<P>
Microsoft Corporation<BR>
Multimedia Systems Group<BR>
Product Marketing<BR>
One Microsoft Way<BR>
Redmond, WA 98052-6399<P>
The <i>Multimedia Developer Registration Kit</i> also lists currently defined multimedia elements.<P>
<b>Chapter </b><P>
<h1>Resource Interchange File Format</h1><P>
The Resource Interchange File Format (RIFF) is a tagged file structure developed for use on multimedia platforms. This chapter defines RIFF and describes the file structures based on RIFF. If your application requires a new file format, you should define it using the RIFF tagged file structure described in this chapter. <P>
<h2>About the RIFF Tagged File Format</h2><P>
RIFF (Resource Interchange File Format) is the tagged file structure developed for multimedia resource files. The structure of a RIFF file is similar to the structure of an Electronic Arts IFF file. RIFF is not actually a file format itself (since it does not represent a specific kind of information), but its name contains the words "interchange file format" in recognition of its roots in IFF. Refer to the EA IFF definition document, <i>EA IFF 85 Standard for Interchange Format Files</i>, for a list of reasons to use a tagged file format.<P>
RIFF has a counterpart, RIFX, that is used to define RIFF file formats that use the Motorola integer byte-ordering format rather than the Intel format. A RIFX file is the same as a RIFF file, except that the first four bytes are 'RIFX' instead of 'RIFF', and integer byte ordering is represented in Motorola format.
RIFF files;structureFile formats;Resource Interchange (RIFF)<P>
<h3>Notation Conventions</h3><P>
The following table lists some of the notation conventions used in this document. Further conventions and the notation for documenting RIFF forms are presented later in the document in the section "Notation for Representing Sample RIFF Files."RIFF files;notational conventions
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Notation</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>&lt;element label&gt;</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>RIFF file element with the label &quot;element label&quot;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>&lt;element label: TYPE&gt;</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>RIFF file element with data type &quot;TYPE&quot;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>[<b>&lt;element label&gt;</b>]</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Optional RIFF file element</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>&lt;element label&gt;</b>...</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>One or more copies of the specified element</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>[<b>&lt;element label&gt;</b>]...</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Zero or more copies of the specified element<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h3>Chunks</h3><P>
The basic building block of a RIFF file is called a <i>chunk</i>. Using C syntax, a chunk can be defined as follows:RIFF chunk;defined in C syntax<P>
typedef unsigned long DWORD;<BR>
typedef unsigned char BYTE;<BR>
<BR>
typedef DWORD FOURCC;    // Four-character code<BR>
<BR>
typedef FOURCC CKID;    // Four-character-code chunk identifier<BR>
typedef DWORD CKSIZE;    // 32-bit unsigned size value<BR>
<BR>
typedef struct {     // Chunk structure<BR>
 CKID     ckID;     // Chunk type identifier<BR>
 CKSIZE     ckSize;     // Chunk size field (size of ckData)<BR>
 BYTE     ckData[ckSize];   // Chunk data<BR>
} CK;<P>
A FOURCC is represented as a sequence of one to four ASCII alphanumeric characters, padded on the right with blank characters (ASCII character value 32) as required, with no embedded blanks.
DWORD, in RIFF chunkRIFF files;FOURCC code inBYTE, in RIFF chunkFOURCCdatatype;inRIFFchunk<P>
For example, the four-character code 'FOO' is stored as a sequence of four bytes: 'F', 'O', 'O', ' ' in ascending addresses. For quick comparisons, a four-character code may also be treated as a 32-bit number.<P>
The three parts of the chunk are described in the following table:RIFF chunk;IDRIFF chunk;size
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Part</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>ckID</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>A four-character code that identifies the representation of the chunk data <b>data</b>. A program reading a RIFF file can skip over any chunk whose chunk ID it doesn't recognize; it simply skips the number of bytes specified by <b>ckSize </b>plus the pad byte, if present.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>ckSize</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>A 32-bit unsigned value identifying the size of <b>ckData</b>. This size value does not include the size of the <b>ckID</b> or <b>ckSize</b> fields or the pad byte at the end of <b>ckData</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>ckData</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Binary data of fixed or variable size. The start of <b>ckData </b>is word-aligned with respect to the start of the RIFF file. If the chunk size is an odd number of bytes, a pad byte with value zero is written after <b>ckData</b>. Word aligning improves access speed (for chunks resident in memory) and maintains compatibility with EA IFF. The <b>ckSize </b>value does not include the pad byte.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
We can represent a chunk with the following notation (in this example, the <b>ckSize </b>and pad byte are implicit):RIFF chunk;notation<P>
&lt;ckID&gt; ( &lt;ckData&gt; )<P>
Two types of chunks, the 'LIST' and 'RIFF' chunks, may contain nested chunks, or subchunks. These special chunk types are discussed later in this document. All other chunk types store a single element of binary data in <b>&lt;ckData&gt;</b>.<P>
<h3>RIFF Forms</h3><P>
A RIFF form is a chunk with a 'RIFF' chunk ID. The term also refers to a file format that follows the RIFF framework. The following is the current list of registered RIFF forms. Each is described in Chapter 3, "Multimedia File Formats."
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Form Type</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>PAL</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>RIFF Palette Format </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>RDIB</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>RIFF Device Independent Bitmap Format </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>RMID</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>RIFF MIDI Format </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>RMMP</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>RIFF Multimedia Movie File Format</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>WAVE</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Waveform Audio Format<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
Using the notation for representing a chunk, a RIFF form looks like the following:RIFF chunk;RIFF form notation<P>
RIFF ( &lt;formType&gt; &lt;ck&gt;... )<P>
The first four bytes of a RIFF form make up a chunk ID with values 'R', 'I', 'F', 'F'. The <b>ckSize </b>field is required, but for simplicity it is omitted from the notation. <P>
The first DWORD of chunk data in the 'RIFF' chunk (shown above as <b>&lt;formType&gt;</b>) is a four-character code value identifying the data representation, or <i>form type</i>, of the file. Following the form-type code is a series of subchunks. Which subchunks are present depends on the form type. The definition of a particular RIFF form typically includes the following:RIFF chunk;in RIFF form<P>
* A unique four-character code identifying the form type<P>
* A list of mandatory chunks<P>
* A list of optional chunks<P>
* Possibly, a required order for the chunks<P>
<h3>Defining and Registering RIFF Forms </h3><P>
The form-type code for a RIFF form must be unique. To guarantee this uniqueness, you must register any new form types before release. See "Registering Multimedia Formats" in Chapter 1, "Overview of Multimedia Specifications," for information on registering RIFF forms.<P>
Like RIFF forms, RIFX forms must also be registered. Registering a RIFF form does not automatically register the RIFX counterpart. No RIFX form types are currently defined. <P>
<h4>Registered Form and Chunk Types</h4><P>
By convention, the form-type code for registered form types contains only digits and uppercase letters. Form-type codes that are all uppercase denote a registered, unique form type. Use lowercase letters for temporary or prototype chunk types.
FOURCCdatatype;and registering form typeRIFF chunk;registering<P>
Certain chunk types are also globally unique and must also be registered before use. These registered chunk types are not specific to a certain form type; they can be used in any form. If a registered chunk type can be used to store your data, you should use the registered chunk type rather than define your own chunk type containing the same type of information. <P>
For example, a chunk with chunk ID 'INAM' always contains the name or title of a file. Also, within all RIFF files, filenames or titles are contained within chunks with ID 'INAM' and have a standard data format.<P>
<h4>Unregistered (Form-Specific) Chunk Types</h4><P>
Chunk types that are used only in a certain form type use a lowercase chunk ID. A lowercase chunk ID has specific meaning only within the context of a specific form type. After a form designer is allocated a registered form type, the designer can choose lowercase chunk types to use within that form. See "Registering Multimedia Formats" in Chapter 1, "Overview of Multimedia Specifications," for information on registering form types.<P>
For example, a chunk with ID 'scln' inside one form type might contain the "number of scan lines." Inside some other form type, a chunk with ID 'scln' might mean "secondary lambda number."<P>
<h2>Notation for Representing Sample RIFF Files</h2><P>
RIFF is a binary format, but it is easier to comprehend an ASCII representation of a RIFF file. This section defines a standard notation used to present samples of various types of RIFF files. If you define a RIFF form, we urge you to use this notation in any file format samples you provide in your documentation.
RIFF files;form notation<P>
<h3>Basic Notation for Representing RIFF Files</h3><P>
The following table summarizes the elements of the RIFF notation required for representing sample RIFF files:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Notation</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>&lt;ckID&gt; (&lt;ckData&gt;)</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The chunk with ID <b>&lt;ckID&gt;</b> and data <b>&lt;ckData&gt;</b>. As previously described, <b>&lt;ckID&gt;</b> is a four-character code which may be enclosed by single quotes for emphasis.<BR>
For example, the following notation describes a 'RIFF' chunk with a form type of 'QRST'. The data portion of this chunk contains a 'FOO' subchunk.<BR>
RIFF('QRST' FOO(17 23))<BR>
The following example describes an 'ICOP' chunk containing the string &quot;Copyright Encyclopedia International.&quot;:<BR>
'ICOP' (&quot;Copyright Encyclopedia International.&quot;Z)<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>&lt;number&gt;[&lt;modifier&gt;]</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>A number in Intel format, where <b>&lt;number&gt;</b> is an optional sign (+ or -) followed by one or more digits and modified by the optional <b>&lt;modifier&gt;</b>. Valid <b>&lt;modifier&gt;</b> values follow:<BR>
<b>Modifier Meaning</b><BR>
None 16-bit number in decimal format<BR>
H 16-bit number in hexadecimal format<BR>
C 8-bit number in decimal format<BR>
CH 8-bit number in hexadecimal format<BR>
L 32-bit number in decimal format<BR>
LH 32-bit number in hexadecimal format<BR>
<BR>
<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Several examples follow:<BR>
0<BR>
65535<BR>
-1<BR>
0L<BR>
4a3c89HL<BR>
-1C<BR>
21HC<BR>
Note that -1 and 65535 represent the same value. The application reading this file must know whether to interpret the number as signed or unsigned.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>'&lt;chars&gt;'</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>A four-character code (32-bit quantity) consisting of a sequence of zero to four ASCII characters <b>&lt;chars&gt;</b> in the given order. If <b>&lt;chars&gt;</b> is less than four characters long, it is implicitly padded on the right with blanks. Two single quotes is equivalent to four blanks. Examples follow.<BR>
'RIFF'<BR>
'xyz'<BR>
''<BR>
<b>&lt;chars&gt;</b> can include escape sequences, which are combinations of characters introduced by a backslash (\) and used to represent other characters. Escape sequences are listed in the following section.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>&quot;&lt;string&gt;&quot;[&lt;modifier&gt;]</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The sequence of ASCII characters contained in <b>&lt;string&gt;</b> and modified by the optional modifier <b>&lt;modifier&gt;</b>. The quoted text can include any of the escape sequences listed in the following section. Valid <b>&lt;modifier&gt;</b> values follow:<BR>
<b>Modifier Meaning</b><BR>
none No NULL terminator or size prefix.<BR>
Z String is NULL-terminated<BR>
B String has an 8-bit (byte) size prefix<BR>
W String has a 16-bit (word) size prefix<BR>
BZ String has a byte-size prefix and is NULL-terminated<BR>
WZ String has a word-size prefix and is NULL-terminated<BR>
<BR>
<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>NULL-terminated means that the string is followed by a character with ASCII value 0. A size prefix is an unsigned integer, stored as a byte or a word in Intel format preceding the string characters, that specifies the length of the string. In the case of strings with BZ or WZ modifiers, the size prefix specifies the size of the string without the terminating NULL.<BR>
The various string formats referred to above are discussed in &quot;Storing Strings in RIFF Chunks,&quot; following later in this section., +<BR>
Examples follow:<BR>
&quot;No prefix, no NULL terminator&quot;<BR>
&quot;No prefix, NULL terminator&quot;Z<BR>
&quot;Byte prefix, NULL terminator&quot;BZ<BR>
<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h3>Escape Sequences for Four-Character Codes and String Chunks</h3><P>
The following escape sequences can be used in four-character codes and string chunks:Strings,inRIFFchunk;escapesequences"RIFF chunk;escape sequencesEscape sequence;list ofFOURCC data type;escape sequencesRIFF files;escape sequencesNew line escape sequenceCarriage return escape sequenceLine feed escape sequenceTab escape sequenceBackspace escape sequence"Backslash escape sequenceQuote character escape sequence<P>

<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Escape Sequence</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>ASCII Value</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>\n</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>10</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Newline character</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>\t</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>9</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Horizontal tab character</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>\b</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>8</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Backspace character</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>\r</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>13</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Carriage return character</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>\f</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>12</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Form feed character</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>\\</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>92</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Backslash</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>-HtmlStart--&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;!--HtmlEnd--&gt;
<TD><FONT FACE="Arial" SIZE=2>39</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Single quote</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>\&quot;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>34</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Double quote</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>\<i>ddd</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Octal <i>ddd</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Arbitrary character<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h3>Extended Notation for Representing RIFF Form Definitions </h3><P>
To unambiguously define the structure of new RIFF forms, document the RIFF form using the basic notation along with the following extended notation:RIFF files;sample file notation
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Notation</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>&lt;name&gt;</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>A label that refers to some element of the file, where <b>&lt;name&gt;</b> is the name of the label. Examples follow:<BR>
&lt;NAME-ck&gt;<BR>
&lt;GOBL-form&gt;<BR>
&lt;bitmap-bits&gt;<BR>
&lt;foo&gt;<BR>
Conventionally, a label that refers to a chunk is named &lt;ckID-ck&gt;, where 'ckID' is the chunk ID. Similarly, a label that refers to a RIFF form is named &lt;formType-form&gt;, where &quot;formType&quot; is the name of the form's type.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>&lt;name&gt; &#221; elements</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The actual data represented by <b>&lt;name&gt;</b> is defined as <b>elements</b>.<BR>
This states that <b>&lt;name&gt;</b> is an abbreviation for <b>elements</b>, where <b>elements</b> is a sequence of other labels and literal data. An example follows:<BR>
&lt;GOBL-form&gt; &#221; RIFF ( 'GOBL' &lt;form-data&gt; )<BR>
This example defines label &lt;GOBL-form&gt; as representing a RIFF form with chunk ID 'GOBL' and data equal to &lt;form-data&gt;, where &lt;form-data&gt; is a label that would be defined in another rule. Note that a label may represent any data, not just a RIFF chunk or form.<BR>
<i><b>Note:</i></b> A number of atomic labels are defined in the section &quot;Atomic Labels&quot; later in this document. These labels refer to primitive data types.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>&lt;name:type&gt;</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>This is the same as <b>&lt;name&gt;</b>, but it also defines <b>&lt;name&gt;</b> to be equivalent to <b>&lt;type&gt;</b>. This notation obviates the following rule:<BR>
&lt;name&gt; &#221; &lt;type&gt;<BR>
This allows you to give a symbolic name to an element of a file format and to specify the element data type. An example follows:<BR>
&lt;xyz-coordinate&gt; &#221; &lt;x:INT&gt; &lt;y:INT&gt; &lt;z:INT&gt;<BR>
This defines &lt;xyz-coordinate&gt; to consist of three parts concatenated together: &lt;x&gt;, &lt;y&gt;, and &lt;z&gt;. The definition also specifies that &lt;x&gt;, &lt;y&gt;, and &lt;z&gt; are integers. This notation is equivalent to the following:<BR>
&lt;xyz-coordinate&gt; &#221; &lt;x&gt; &lt;y&gt; &lt;z&gt;<BR>
&lt;x&gt; &#221; &lt;INT&gt;<BR>
&lt;y&gt; &#221; &lt;INT&gt;<BR>
&lt;z&gt; &#221; &lt;INT&gt;<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>[elements]</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>An optional sequence of labels and literal data. Surrounded by square brackets, it may be considered an element itself. An example follows:<BR>
&lt;FOO-form&gt; &#221; RIFF('FOO' [&lt;header-ck&gt;] &lt;data-ck&gt;)<BR>
This example defines form &quot;FOO&quot; with an optional header chunk followed by a mandatory data chunk.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>el1 &#124; el2 &#124; ... &#124; elN</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Exactly one of the listed elements must be present. An example follows:<BR>
&lt;hdr-ck&gt; &#221; hdr(&lt;hdr-x&gt; &#124; &lt;hdr-y&gt; &#124; &lt;hdr-z&gt;)<BR>
This example defines the 'hdr' chunk's data as containing one of &lt;hdr-x&gt;, &lt;hdr-y&gt;, or &lt;hdr-z&gt;.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>element...</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>One or more occurrences of <b>element</b> may be present. An ellipsis has this meaning only if it follows an element; in cases such as &quot;el1 &#124; el2 &#124; ... &#124; elN,&quot; the ellipsis has its ordinary English meaning. If there is any possibility of confusion, an ellipsis should only be used to indicate one or more occurrences. An example follows:<BR>
&lt;data-ck&gt; &#221; data(&lt;count:INT&gt; &lt;item:INT&gt;...)<BR>
This example defines the data of the 'data' chunk to contain an integer &lt;count&gt;, followed by one or more occurrences of the integer &lt;item&gt;. <BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>[element]...</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Zero or more occurrences of <b>element</b> may be present. An example follows.<BR>
&lt;data-ck&gt; &#221; data(&lt;count:INT&gt; [&lt;item:INT&gt;]...)<BR>
This example defines the data of the 'data' chunk to contain an integer &lt;count&gt; followed by zero or more occurrences of an integer &lt;item&gt;.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>{elements}</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The group of elements within the braces should be considered a single element. An example follows:<BR>
&lt;blorg&gt; &#221; &lt;this&gt; &#124; {&lt;that&gt; &#124; &lt;other&gt;}...<BR>
This example defines &lt;blorg&gt; to be either &lt;this&gt; or one or more occurrences of &lt;that&gt; or &lt;other&gt;, intermixed in any way. Contrast this with the following example:<BR>
&lt;blorg&gt; &#221; &lt;this&gt; &#124; &lt;that&gt; &#124; &lt;other&gt;...<BR>
This example defines &lt;blorg&gt; to be either &lt;this&gt; or &lt;that&gt; or one or more occurrences of &lt;other&gt;.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>

<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>struct { ...} name</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>A structure defined using C syntax. This can be used instead of a sequence of labels if a C header (include) file is available that defines the structure. The label used to refer to the structure should be the same as the structure's typedef name. An example follows:<BR>
&lt;3D_POINT&gt; &#221; struct {<BR>
     INT x;        // x-coordinate<BR>
     INT y;    // y-coordinate<BR>
     INT z;    // z-coordinate<BR>
    } 3D_POINT<BR>
Wherever possible, the types used in the structure should be the types listed in the following section, &quot;Atomic Labels,&quot; because these types are more portable than C types such as int. The structure fields are assumed to be present in the file in the order given, with no padding or forced alignment.<BR>
Unless the RIFF chunk ID is 'RIFX', integer byte ordering is assumed to be in Intel format.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>// comment</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>An explanatory comment to a rule. An example follows:<BR>
&lt;weekend&gt; &#221; 'Sat'&#124;'Sun'   // Four-character code <BR>
        // for day<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h3>Atomic Labels</h3><P>
The following are atomic labels, which are labels that refer to primitive data types. Where available, the equivalent Microsoft C data type is also listed.<BR>
DatatypelabelsAtomic labelsRIFF files;primitive data type labels
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Label</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Meaning</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b> MS C Type</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&lt;CHAR&gt;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>8-bit signed integer</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>signed char</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&lt;BYTE&gt;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>8-bit unsigned quantity</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>unsigned char</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&lt;INT&gt;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>16-bit signed integer in Intel format</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>signed int</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&lt;WORD&gt;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>16-bit unsigned quantity in Intel format</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>unsigned int</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&lt;LONG&gt;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>32-bit signed integer in Intel format</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>signed long</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&lt;DWORD&gt;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>32-bit unsigned quantity in Intel format</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>unsigned long</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&lt;FLOAT&gt;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>32-bit IEEE floating point number</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>float</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&lt;DOUBLE&gt;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>64-bit IEEE floating point number</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>double </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&lt;STR&gt;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>String (a sequence of characters)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&lt;ZSTR&gt;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>NULL-terminated string</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&lt;BSTR&gt;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>String with byte (8-bit) size prefix</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&lt;WSTR&gt;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>String with word (16-bit) size prefix</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&lt;BZSTR&gt;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>NULL-terminated string with byte size prefix</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&lt;WZSTR&gt;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>NULL-terminated string with word size prefix<BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
NULL-terminated means that the string is followed by a character with ASCII value 0.<P>
A size prefix is an unsigned integer, stored as a byte or a word in Intel format, that specifies the length of the string. In the case of strings with BZ or WZ modifiers, the size prefix specifies the size of the string without the terminating NULL.<P>
<note><i><b>Note:</b></i> The WINDOWS.H header file defines the C types BYTE, WORD, LONG, and DWORD. These types correspond to labels &lt;BYTE&gt;, &lt;WORD&gt;, &lt;LONG&gt;, and &lt;DWORD&gt;, respectively.</note><P>
<h3>A Sample RIFF Form Definition and RIFF Form </h3><P>
The following example defines &lt;GOBL-form&gt;, the hypothetical RIFF form of type 'GOBL'. To fully document a new RIFF form definition, a developer would also provide detailed descriptions of each file element, including the semantics of each chunk and sample files documented using the standard notation.
RIFF forms;example of definition<P>
&lt;GOBL-form&gt; &#221;   RIFF( 'GOBL'     // RIFF form header<BR>
            [&lt;org-ck&gt;]   // Origin chunk (default (0,0,0))<BR>
       &lt;obj-list&gt;)   // Series of graphical objects<BR>
<BR>
&lt;org-ck&gt; &#221;   org(  &lt;origin:3D_POINT&gt; )   // Object-list origin<BR>
<BR>
            // An object is a:<BR>
&lt;obj-list&gt; &#221;   LIST( 'obj' { &lt;sqr-ck&gt;  |     // square,<BR>
                 &lt;circ-ck&gt; |     // circle,<BR>
                 &lt;poly-ck&gt;  }... )   // or polygon<BR>
<BR>
&lt;sqr-ck&gt; &#221;   sqr( &lt;pt1:3D_POINT&gt;   // one vertex<BR>
       &lt;pt2:3D_POINT&gt;   // another vertex<BR>
       &lt;pt3:3D_POINT&gt; )  // a third vertex<BR>
<BR>
&lt;circ-ck&gt; &#221;   circ( &lt;center:3D_POINT&gt;    // Center of circle<BR>
       &lt;circumPt:3D_POINT&gt; )   // Point on circumference<BR>
<BR>
&lt;poly-ck&gt; &#221;   poly( &lt;pt:3D_POINT&gt;... )  // List of points in a polygon<BR>
<BR>
&lt;3D_POINT&gt; &#221;   struct      // Defined in &quot;gobl.h&quot;<BR>
     { INT x;      // x-coordinate<BR>
      INT y;      // y-coordinate<BR>
      INT z;      // z-coordinate<BR>
     } 3D_POINT<P>
<h5><b>Sample RIFF Form</b></h5><P>
The following sample RIFF form adheres to the form definition for form type GOBL. The file contains three subchunks:RIFF forms;exampleRIFF chunk;example<P>
* An 'INFO' list<P>
* An 'org' chunk<P>
* An 'obj' chunk<P>
The 'INFO' list and 'org' chunk each have two subchunks. The 'INFO' list is a registered global chunk that can be used within any RIFF file. The 'INFO' list is described in the 'INFO List Chunk," later in this chapter.
RIFF chunk;INFO chunkINFO chunkRIFF files;INFO chunk<P>
Since the definition of the GOBL form does not refer to the INFO chunk, software that expects only 'org' and 'obj' chunks in a GOBL form would ignore the unknown 'INFO' chunk.<P>
RIFF( 'GOBL'<BR>
     LIST('INFO'   // INFO list containing filename and copyright<BR>
       INAM(&quot;A House&quot;Z)<BR>
       ICOP(&quot;(C) Copyright Encyclopedia International 1991&quot;Z)<BR>
     )<BR>
<BR>
  org(2, 0, 0)  // Origin of object list<BR>
<BR>
  LIST('obj'    // Object list containing two polygons<BR>
    poly(0,0,0  2,0,0  2,2,0, 1,3,0, 0,2,0)<BR>
    poly(0,0,5  2,0,5  2,2,5, 1,3,5, 0,2,5)<BR>
    )<BR>
    )      // End of form<P>
<h2>Storing Strings in RIFF Chunks</h2><P>
This section lists methods for storing text strings in RIFF chunks. While these guidelines may not make sense for all applications, you should follow these conventions if you must make an arbitrary decision regarding string storage.
RIFF chunk;text strings in<P>
<h4>NULL-Terminated String (ZSTR) Format</h4><h4>ZSTR format, in RIFF chunk</h4><P>
A NULL-terminated string (ZSTR) consists of a series of characters followed by a terminating NULL character. The ZSTR is better than a simple character sequence (STR) because many programs are easier to write if strings are NULL-terminated. ZSTR is preferred to a string with a size prefix (BSTR or WSTR) because the size of the string is already available as the <b>&lt;ckSize&gt; </b>value, minus one for the terminating NULL character.
WSTR format, in RIFF chunkBSTR format, in RIFF chunk<P>
<h4>String Table Format</h4><h4>String table format, in RIFF chunk</h4><P>
In a string table, all strings used in a structure are stored at the end of the structure in packed format. The structure includes fields that specify the offsets from the beginning of the string table to the individual strings. An example follows:<P>
typedef struct   <BR>
{    <BR>
 INT  iWidgetNumber;  // the widget number<BR>
 WORD offszWidgetName; // an offset to a string in &lt;rgchStrTab&gt;<BR>
 WORD offszWidgetDesc; // an offset to a string in &lt;rgchStrTab&gt;<BR>
 INT  iQuantity;   // how many widgets<BR>
 CHAR rgchStrTab[1];  // string table (allocate as large as needed)<BR>
} WIDGET;<P>
If multiple chunks within the file need to reference variable-length strings, you can store the strings in a single chunk that acts as a string table. The chunks that refer to the strings contain offsets relative to the beginning of the data part of the string table chunk.<P>
<h4>NULL-Terminated, Byte Size Prefix String (BZSTR) Series</h4><h4>BZSTR format, in RIFF chunk</h4><P>
In a BZSTR series, a series of strings is stored in packed format. Each string is a BZSTR, with a byte size prefix and a NULL terminator. This format retains the ease-of-use characteristics of the ZSTR while providing the string size, allowing the application to quickly skip unneeded strings.<P>
<h4>Multiline String Format</h4><P>
When storing multiline strings, separate lines with a carriage return/line feed pair (ASCII 13/ASCII 10 pair). Although applications vary in their requirements for new line symbols (carriage return only, line feed only, or both), it is generally easier to strip out extra characters than to insert extra ones. Inserting characters might require reallocating memory blocks or pre-scanning the chunk before allocating memory for it.
Multiline string format, in RIFF chunk<P>
<h4>Choosing a Storage Method</h4><P>
The following lists guidelines for deciding which storage method is appropriate for your application. Strings, in RIFF chunk;storage methods<P>

<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Usage</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Recommended Format</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>Chunk data contains nothing except a string</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>ZSTR (NULL-terminated string) format. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>Chunk data contains a number of fields, some of which are variable-length strings</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>String-table format </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>Multiple chunks within the file need to reference variable-length strings</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>String-table format </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>Chunk data stores a sequence of strings, some of which the application may want to skip</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BZSTR (NULL-terminated string with byte size prefix) series </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>Chunk data contains multiline strings</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>A multiline string format <BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h2>LIST Chunk</h2><P>
A LIST chunk contains a list, or ordered sequence, of subchunks. A LIST chunk is defined as follows:<P>
LIST( &lt;list-type&gt; [&lt;chunk&gt;]... )<P>
The <b>&lt;list-type&gt; </b>is a four-character code that identifies the contents of the list.<P>
If an application recognizes the list type, it should know how to interpret the sequence of subchunks. However, since a LIST chunk may contain only subchunks (after the list type), an application that does not know about a specific list type can still walk through the sequence of subchunks.<P>
Like chunk IDs, list types must be registered, and an all-lowercase list type has meaning relative to the form that contains it. See "Registering Multimedia Formats" in Chapter 1, "Overview of Multimedia Specifications," for information on registering list types.<P>
<h3>INFO List Chunk</h3><P>
The 'INFO' list is a registered global form type that can store information that helps identify the contents of the chunk. This information is useful but does not affect the way a program interprets the file; examples are copyright information and comments. An 'INFO' list is a 'LIST' chunk with list type 'INFO'. The following shows a sample 'INFO' list chunk:<P>
LIST('INFO' INAM(&quot;Two Trees&quot;Z) <BR>
   ICMT(&quot;A picture for the opening screen&quot;Z) )<P>
An 'INFO' list should contain only the following chunks. New chunks may be defined, but an application should ignore any chunk it doesn't understand. The chunks listed below may only appear in an 'INFO' list. Each chunk contains a ZSTR, or null-terminated text string.
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Chunk ID</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b> Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>IARL</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Archival Location.</i> Indicates where the subject of the file is archived.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>IART</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Artist.</i> Lists the artist of the original subject of the file. For example, &quot;Michaelangelo.&quot;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>ICMS</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Commissioned.</i> Lists the name of the person or organization that commissioned the subject of the file. For example, &quot;Pope Julian II.&quot;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>ICMT</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Comments.</i> Provides general comments about the file or the subject of the file. If the comment is several sentences long, end each sentence with a period. Do <i>not</i> include newline characters.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>ICOP</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Copyright.</i> Records the copyright information for the file. For example, &quot;Copyright Encyclopedia International 1991.&quot; If there are multiple copyrights, separate them by a semicolon followed by a space.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>ICRD</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Creation date.</i> Specifies the date the subject of the file was created. List dates in year-month-day format, padding one-digit months and days with a zero on the left. For example, &quot;1553-05-03&quot; for May 3, 1553.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>ICRP</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Cropped.</i> Describes whether an image has been cropped and, if so, how it was cropped. For example, &quot;lower right corner.&quot;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>IDIM</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Dimensions.</i> Specifies the size of the original subject of the file. For example, &quot;8.5 in h, 11 in w.&quot;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>IDPI</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Dots Per Inch.</i> Stores dots per inch setting of the digitizer used to produce the file, such as &quot;300.&quot;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>IENG</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Engineer.</i> Stores the name of the engineer who worked on the file. If there are multiple engineers, separate the names by a semicolon and a blank. For example, &quot;Smith, John; Adams, Joe.&quot;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>IGNR</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Genre.</i> Describes the original work, such as, &quot;landscape,&quot; &quot;portrait,&quot; &quot;still life,&quot; etc.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>IKEY</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Keywords.</i> Provides a list of keywords that refer to the file or subject of the file. Separate multiple keywords with a semicolon and a blank. For example, &quot;Seattle; aerial view; scenery.&quot;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>ILGT</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Lightness.</i> Describes the changes in lightness settings on the digitizer required to produce the file. Note that the format of this information depends on hardware used.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>IMED</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Medium.</i> Describes the original subject of the file, such as, &quot;computer image,&quot; &quot;drawing,&quot; &quot;lithograph,&quot; and so forth.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>INAM</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Name.</i> Stores the title of the subject of the file, such as, &quot;Seattle From Above.&quot;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>IPLT</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Palette Setting.</i> Specifies the number of colors requested when digitizing an image, such as &quot;256.&quot;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>IPRD</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Product.</i> Specifies the name of the title the file was originally intended for, such as &quot;Encyclopedia of Pacific Northwest Geography.&quot;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>ISBJ</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Subject.</i> Describes the conbittents of the file, such as &quot;Aerial view of Seattle.&quot;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>ISFT</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Software.</i> Identifies the name of the software package used to create the file, such as &quot;Microsoft WaveEdit.&quot;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>ISHP</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Sharpness.</i> Identifies the changes in sharpness for the digitizer required to produce the file (the format depends on the hardware used).</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>ISRC</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Source.</i> Identifies the name of the person or organization who supplied the original subject of the file. For example, &quot;Trey Research.&quot;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>ISRF</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Source Form.</i> Identifies the original form of the material that was digitized, such as &quot;slide,&quot; &quot;paper,&quot; &quot;map,&quot; and so forth. This is not necessarily the same as IMED.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>ITCH</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>Technician.</i> Identifies the technician who digitized the subject file. For example, &quot;Smith, John.&quot;<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h2>CSET (Character Set) Chunk</h2><P>
To define character-set and language information for a RIFF file, use the CSET chunk. The CSET chunk defines the code page and country,  language, and dialect codes for the file. These values can be overridden for specific file elements; see "Usage Codes for Extra Header and Extra Entry Fields," later in this chapter, for information on specifying character set information in a compound file.<P>
The CSET chunk is defined as follows:<P>
&lt;CSET chunk&gt; &#221; CSET( &lt;wCodePage:WORD&gt;<P>
      &lt;wCountryCode:WORD&gt;<P>
      &lt;wLanguageCode:WORD&gt;<P>
      &lt;wDialect:WORD&gt; )<P>
The fields are as follows:
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Field</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wCodePage</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the code page used for file elements. If the CSET chunk is not present, or if this field has value zero, assume standard ISO 8859/1 code page (identical to code page 1004 without code points defined in hex columns 0, 1, 8, and 9).</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wCountryCode</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the country code used for file elements. See &quot;Country Codes,&quot; following this section, for a list of currently defined country codes.<BR>
If the CSET chunk is not present, or if this field has value zero, assume USA (country code 001). <BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wLanguage</b>, <BR>
<b>wDialect</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specify the language and dialect used for file elements. See &quot;Language and Dialect Codes,&quot; later in this chapter, for a list of language and dialect codes.<BR>
If the CSET chunk is not present, or if these fields have value zero, assume US English (language code 9, dialect code 1).<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h3>Country Codes</h3><P>
Use one of the following country codes in the <b>wCountryCode</b> field:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Country Code</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Country</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>000</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>None (ignore this field)</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>001</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>USA</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>002 </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Canada</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>003</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Latin America</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>030</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Greece</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>031</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Netherlands</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>032</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Belgium</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>033</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>France</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>034</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Spain</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>039</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Italy</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>041</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Switzerland</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>043</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Austria</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>044</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>United Kingdom</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>045</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Denmark</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>046</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sweden</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>047</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Norway</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>049</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>West Germany</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>052</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Mexico</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>055</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Brazil</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>061</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Australia</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>064</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>New Zealand</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>081</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Japan</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>082</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Korea</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>086</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>People's Republic of China</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>088</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Taiwan</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>090</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Turkey</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>351</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Portugal</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>352</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Luxembourg</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>354</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Iceland</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>358 </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Finland<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h3>Language and Dialect Codes</h3><P>
Specify one of the following pairs of language-code and dialect-code values in the <b>wLanguage</b> and <b>wDialect</b> fields:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Language Code</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Dialect Code</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Language</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>0</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>0</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>None (ignore these fields)</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Arabic</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>2</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Bulgarian</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>3</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Catalan</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>4</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Traditional Chinese</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>4</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>2</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Simplified Chinese</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>5</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Czech</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>6</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Danish</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>7</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>German</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>7</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>2</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Swiss German</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>8</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Greek</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>9</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>US English</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>9</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>2</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>UK English</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>10</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Spanish</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>10</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>2</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Spanish Mexican</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>11</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Finnish</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>12</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>French</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>12</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>2</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Belgian French</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>12</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>3</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Canadian French</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>12</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>4</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Swiss French</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>13</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Hebrew</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>14</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Hungarian</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>15</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Icelandic</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>16</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Italian</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>16</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>2</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Swiss Italian</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>17</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Japanese</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>18</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Korean</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>19</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Dutch</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>19</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>2</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Belgian Dutch</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>20</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Norwegian - Bokmal</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>20</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>2</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Norwegian - Nynorsk</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>21</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Polish</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>22</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Brazilian Portuguese</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>22</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>2</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Portuguese</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>23</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Rhaeto-Romanic</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>24</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Romanian</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>25</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Russian</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>26</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Serbo-Croatian (Latin)</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>26</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>2</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Serbo-Croatian (Cyrillic)</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>27</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Slovak</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>28</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Albanian</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>29</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Swedish</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>30</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Thai</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>31</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Turkish</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>32</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Urdu</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>33</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Bahasa<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h2>JUNK (Filler) Chunk</h2><P>
A JUNK chunk represents padding, filler or outdated information. It contains no relevant data; it is a space filler of arbitrary size. The JUNK chunk is defined as follows:<P>
&lt;JUNK chunk&gt; &#221; JUNK( &lt;filler&gt; )<P>
where <b>&lt;filler&gt;</b> contains random data. <P>
<h2>Compound File Structure</h2><P>
The compound file structure is a RIFF-based structure upon which multimedia file formats can be defined. The compound file structure is a parameterized structure that provides for the following:<P>
* Storage of multimedia data elements<P>
* Direct access to multimedia data elements (as opposed to sequential searching)<P>
The goals of the compound file structure are to maximize flexibility and extensibility while minimizing implementation costs. Using the compound file structure, developers of multimedia data formats can define both simple and complex file formats.<P>
The structure is flexible enough to be used for many purposes, but it can be simplified for use with simple file formats. Designers of new multimedia file formats can restrict the use of standard header fields, requiring some and removing others.<P>
For example, a developer might define a compound file format that stores a series of bitmaps in a single file, thus reducing compact disc seek times. Another developer might define a compound file format that contains a special type of audio resource, using the compound file header information to identify the attributes of the audio data stored within.<P>
<h3>Structural Overview</h3><P>
Files based upon the compound file structure contain the following two RIFF chunks at their topmost level:<P>
* Compound File Table of Contents (CTOC) chunk<P>
* Compound File Element Group (CGRP) chunk<P>
The CTOC chunk indexes the CGRP chunk, which contains the actual multimedia data elements. Defined using the standard chunk notation, a compound file is represented as follows:<P>
&lt;compound file&gt; &#221; RIFF('type' &lt;CTOC&gt; &lt;CGRP&gt;)<P>
where 'type' is a FOURCC indicating the file type.<P>
This section describes the CTOC and CGRP chunks in detail.<P>
<h3>Compound File Table of Contents (CTOC) Chunk</h3><P>
The CTOC chunk functions mainly as an index, allowing direct access to elements within a compound file. The CTOC chunk also contains information about the attributes of the entire file and of each media element within the file.<P>
To provide the maximum flexibility for defining compound file formats, the CTOC chunk can be customized at several levels. The CTOC chunk contains fields whose length and usage is defined by other CTOC fields. This parameterization adds complexity, but it provides flexibility to file format designers and allows applications to correctly read data without necessarily knowing the specific file format definition.<P>
<h4>Structural Overview</h4><P>
The CTOC chunk defines the contents of the CGRP chunk. The CTOC chunk has the following components:<P>
* Header information defining the size of the CTOC chunk, the number of entries in the CGRP chunk, the size of the CGRP chunk, and general information about the entire header file <P>
* A parameter table definition defining the size and contents of the header parameter table and CTOC table entries<P>
* A header parameter table defining attributes that apply to the entire compound file.<P>
* CTOC table entries defining the location, size, name, and attributes of the compound file elements contained in the CGRP chunk.<P>
These components appear sequentially in the CTOC chunk. The individual fields in the CTOC chunk are the following:<P>
&lt;CTOC-chunk&gt;&#221; CTOC (<BR>
 &lt;dwHeaderSize:DWORD&gt;    // Header information<BR>
 &lt;dwEntriesTotal:DWORD&gt;<BR>
 &lt;dwEntriesDeleted:DWORD&gt;<BR>
 &lt;dwEntriesUnused:DWORD&gt;<BR>
 &lt;dwBytesTotal:DWORD&gt;<BR>
 &lt;dwBytesDeleted:DWORD&gt;<BR>
 &lt;dwHeaderFlags:DWORD&gt;<BR>
<BR>
 &lt;wEntrySize:WORD&gt;     // Parameter table definition<BR>
 &lt;wNameSize:WORD&gt;<BR>
 &lt;wExHdrFields:WORD&gt;<BR>
 &lt;wExEntFields:WORD&gt;<BR>
 &lt;awExHdrFldUsage:WORD[wExHdrFields]&gt;<BR>
 &lt;awExEntFldUsage:WORD[wExEntFields]&gt;<BR>
<BR>
          // Header parameter table<BR>
 &lt;adwExHdrField:DWORD[wExHdrFields]&gt;<BR>
 [&lt;bHeaderPad:BYTE&gt;]<BR>
 [&lt;CTOC-table-entry&gt;]    // CTOC table entries<BR>
)<P>
Each CTOC table entry is defined as follows:<P>
&lt;CTOC-table-entry&gt; &#221; <BR>
 &lt;dwOffset:DWORD&gt;<BR>
 &lt;dwSize:DWORD&gt;<BR>
 &lt;dwMedType:DWORD&gt;<BR>
 &lt;dwMedUsage:DWORD&gt;<BR>
 &lt;dwCompressTech:DWORD&gt;<BR>
 &lt;dwUncompressBytes:DWORD&gt;<BR>
 &lt;adwExEntField:DWORD[wExEntFields]&gt;<BR>
 &lt;bEntryFlags:BYTE&gt;<BR>
 &lt;achName:CHAR[wNameSize]&gt;<BR>
 [&lt;bEntryPad:BYTE&gt;]...<P>
The following sections describe each field in detail.<P>
<h4>Header Information</h4><P>
The header information section defines general information about the CTOC header and about the entire compound file. It contains the following fields:<P>

<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Field Name</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwHeaderSize</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Combined size of header information, parameter table definition, and header parameter table. Use this value to locate the start of the CTOC table entries within the CTOC chunk.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwEntriesTotal</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Total number of CTOC table entries, including unused entries and entries corresponding to deleted elements.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwEntriesDeleted</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Number of CTOC table entries that correspond to deleted elements.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwEntriesUnused</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Number of CTOC table entries that are unused.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwBytesTotal</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Combined size of all CGRP elements, including deleted elements.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwBytesDeleted</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Combined size of all deleted CGRP elements.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwHeaderFlags</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Flags that give information about the entire compound file. The following flags may be used:<BR>
CTOC_HF_SEQUENTIAL<BR>
Valid CTOC table entries are arranged in sequential order. If this flag is not set, the CTOC table entries may be in an arbitrary order.<BR>
CTOC_HF_MEDSUBTYPE<BR>
The <b>dwMedUsage</b> field of each CTOC table entry contains a FOURCC that indicates how the element is used. If this flag is not set, the <b>dwMedUsage</b> field contains information as defined by the form type.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h4>Parameter Table Definition</h4><P>
The parameter table definition defines the size and contents of the header parameter table and CTOC table. It contains the following fields:<P>

<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Field Name</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wEntrySize</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Size of each CTOC table entry, including any pad bytes.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wNameSize</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Size of the <b>achName</b> field of each CTOC table entry. Each <b>achName</b> field must be padded with null characters to this length. The <b>achName</b> field is a null-terminated string, so it always contains at least one trailing null character.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wExHdrFields</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Number of extra header fields, or entries in the <b>awExHdrFldUsage</b> and <b>adwExHdrField</b> arrays.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wExEntFields</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Number of extra entry fields, or entries in the <b>awExEntFldUsage</b> and <b>adwExHdrField</b> arrays.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>awExHdrFldUsage</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Array of extra header field usage fields. Each entry in this array corresponds to the same numbered entry in the <b>adwExHdrField</b> array and defines how that entry is interpreted. Valid usage codes for each field in this array are listed in &quot;Usage Codes for Extra Header and Extra Entry Fields,&quot; later in this chapter. The number of WORDs in this array is defined by the <b>wExHdrFields</b> value.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>awExEntFldUsage</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Array of extra entry field usage fields. Each entry in this array corresponds to the same numbered entry in the <b>adwExEntField</b> array, present in each CTOC table entry, and defines how that entry is interpreted. Valid usage codes for each field in this array are listed in &quot;Usage Codes for Extra Header and Extra Entry Fields,&quot; later in this chapter. The number of WORDs in this array is defined by the <b>wExEntFields</b> value.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h4>Header Parameter Table</h4><P>
The header parameter table is an optional component generally used to define attributes of the entire compound file.
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Field Name</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Type</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>adwExHdrField</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Extra header fields. The usage of each cell in the array is defined by the corresponding cell in the <b>awExHdrFldUsage</b> array.<BR>
The number of DWORDs in this array is defined by the <b>wExHdrFields</b> value.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>bHeaderPad</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Zero or more NULL pad bytes. There must be enough padding in this field to make the CTOC header an even number of bytes in length.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h4>CTOC Table Entries</h4><P>
The CTOC table entries define the location, size, name, and other information about the individual compound file elements contained in the CGRP chunk. The number of CTOC table entries is determined by the <b>dwEntriesTotal</b> field in the header information of the CTOC chunk. <P>
Each CTOC table entry is a structure containing the following fields:
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Field Name</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwOffset</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Byte offset of the compound file element measured from the beginning of the data portion of the CGRP chunk.<BR>
For example, if <b>dwOffset</b> is 1000 and the chunk ID of the CGRP chunk is at offset 500, the element is at offset 1508 (1000+500+4 (chunk ID)+4 (chunk size field)).<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwSize</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Size of the element in bytes.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwMedType</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>FOURCC value identifying the media element type of the compound file element. This field may be zero if the compound file element is not to be interpreted as a standalone file. If the compound file element is a RIFF form, then the media element type is the same as the RIFF form type.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwMedUsage</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Extra usage information for the compound file element.<BR>
If the CTOC_HF_MEDSUBTYPE flag is set in the <b>dwHeaderFlags</b> field, this field contains a FOURCC that indicates how the element is used. To avoid name conflicts, this FOURCC must be registered. See &quot;Registering Multimedia Formats&quot; in Chapter 1, &quot;Overview of Multimedia Specifications,&quot; for information on usage codes.<BR>
If the CTOC_HF_MEDSUBTYPE flag is not set in the <b>dwHeaderFlags</b> field, this field contains 32 bits of information interpreted as defined by the form type.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwCompressTech</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Compression technique used to compress the media element. If this value is zero, the element is not compressed. See &quot;Compression of Compound File Elements,&quot; later in this chapter, for more information.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwUncompressBytes</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Number of bytes the compound file element occupies in memory after decompression. This value assumes the decompression technique identified in the <b>dwCompressTech</b> field. If the <b>dwCompressTech</b> field is 0, then the compound file element is not compressed, and this field should equal the <b>dwSize</b> field.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>adwExEntField</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Array of extra entry fields defining attributes of this compound file element. The usage of each cell in the array is defined by the corresponding cell in the <b>awExEntFldUsage</b> array.<BR>
The number of DWORDs in this array is defined by the <b>wExEntFields</b> value.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>bEntryFlags</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Flags giving information about the compound file element or this CTOC table entry. Possible values follow; these may be combined:<BR>
CTOC_EF_DELETED<BR>
Compound file is marked as deleted and should not be accessed. Do not combine this flag with the CTOC_EF_UNUSED flag.<BR>
CTOC_EF_UNUSED<BR>
CTOC table entry is unused and does not refer to any compound file element. This entry can be used to refer to a new compound file element. Do not combine this flag with the CTOC_EF_DELETED flag.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>achName</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Array of characters containing the name of the compound file element. The number of bytes in this array is defined by the <b>wNameSize</b> value.<BR>
The string must be padded on the right with NULL characters and must be terminated by at least one NULL character. This field must be an odd number of bytes in length and must be at least one byte long.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>bEntryPad</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Zero or more NULL pad bytes as needed to make the table entry an even number of bytes in length.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h4>Usage Codes for Extra Header and Extra Entry Fields</h4><P>
The following are valid usage codes for elements in the <b>awExHdrFldUsage</b> and <b>awExEntFldUsage</b> arrays, both of which are fields of the CTOC header. These arrays define the meaning of data stored in the <b>adwExHdrField</b> and <b>adwExEntField</b> "extra fields." All usage codes apply to both header fields and entry fields, unless explicitly stated otherwise.<P>
Values marked in the extra header field arrays generally apply to all elements in the CFRG chunk, while values marked in the extra entry field arrays generally apply only to the element referenced by the corresponding CTOC table entry.
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Flag</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>CTOC_EFU_UNUSED (0x00)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The field is unused. This usage code may be used to logically delete a header field.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>CTOC_EFU_LASTMODTIME (0x01)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>When used to describe an extra header field, the field contains the time that any portion of the CTOC or CGRP was last modified.<BR>
When used to describe an extra entry field, the field contains the time that the corresponding CTOC table entry, or the compound file element it refers to, was last modified.<BR>
The field is interpreted as a DWORD containing the number of seconds that have elapsed since 00:00:00 Greenwich Mean Time (GMT), January 1, 1970.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>CTOC_EFU_CODEPAGE</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The field contains the code page and country code for the <b>achName</b> field. These values override any values specified in a CSET chunk. <BR>
When used to describe an extra header field, the field contains code-page and country-code information for all CTOC table entries. When used to describe an extra entry field, the field contains information for that specific CTOC table entry. <BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The low-order word of the field contains one of the following code page values:<BR>
Zero<BR>
Use standard ISO 8859/1 code page. This is identical to code page 1004 without code points defined in hex columns 0, 1, 8, and 9.<BR>
CTOC_CHARSET_CODEPAGE (0x0000<i>nnnn</i>)<BR>
Use code page 0x<i>nnnn</i>, where 0x<i>nnnn</i> is the 16-bit code page number. For example, 0x00000352 for OS/2 code page 850, or 0x000004E4 for Windows 3.1 code page 1252.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The high-order word contains one of the following country codes:<BR>
Zero<BR>
Ignore this field.<BR>
Country code<BR>
See &quot;Country Codes,&quot; earlier in this chapter, for a list of currently defined country codes.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>CTOC_EFU_LANGUAGE</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The field contains language and dialect information for the <b>achName</b> field.  These values override any values specified in a CSET chunk. <BR>
When used to describe an extra header field, the field contains language information for all CTOC table entries. When used to describe an extra entry field, the field contains information for that specific CTOC table entry. <BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The low-order word of the field contains one of the following language codes:<BR>
Zero<BR>
Ignore this field.<BR>
Language code<BR>
See &quot;Language and Dialect Codes,&quot; earlier in this chapter, for a list of currently defined language codes.<BR>
The high-order word of the field contains one of the following dialect codes:<BR>
Zero<BR>
Ignore this field.<BR>
Dialect code<BR>
See &quot;Language and Dialect Codes,&quot; earlier in this chapter, for a list of currently defined dialect codes.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>CTOC_EFU_COMPRESSPARAM0 (0x05) through CTOC_EFU_COMPRESSPARAM9 (0x14)<BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies a compression parameter. See &quot;Compression of Compound File Elements,&quot; later in this chapter.<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h4>Compression of Compound File Elements</h4><P>
Compound file elements can be compressed. The <b>dwCompressTech</b> field of a CTOC table entry contains a FOURCC compression technique identifier for the corresponding compound file element. If the field is zero, the compound file element is not compressed.<P>
The definition of a specific compression technique may specify that either the entire compound file element is compressed, or that some specific subset, for example one or more RIFF chunks, is compressed.<P>
The <b>dwUncompressSize</b> field contains the number of bytes that the compound file element will occupy in memory after decompression. If the compound file element is not compressed, this field contain the same value as the <b>dwSize</b> field, which identifies the file size of the compound file element.<P>
Compression techniques may demand extra header fields or extra entry fields for decompression parameters. Compression technique identifiers, and any new entry fields corresponding to decompression technique parameters, must be unique. See "Registering Multimedia Formats" in Chapter 1, "Overview of Multimedia Specifications," for information on registering compression techniques.<P>
<h3>Compound File Element Group (CGRP) Chunk</h3><P>
The actual elements of data referenced by the CTOC chunk are stored in a compound file Element Group (CGRP) chunk. The CGRP chunk contains all the compound file elements, concatenated together into one contiguous block of data. Some of the elements in the CGRP chunk might be unused, if the element was marked for deletion or was altered and stored elsewhere within the CGRP chunk.<P>
Elements within the CGRP chunk are of arbitrary size and can appear in a specific or arbitrary order, depending upon the file format definition. Each element is identified by a corresponding CTOC table entry.<P>
Using the standard RIFF notation, the CGRP chunk is defined as follows:<P>
&lt;CGRP-chunk&gt; &#221; CGRP([&lt;compound file element&gt;]...)<P>
<h3>Placement of the CTOC and CGRP Chunks</h3><P>
The specific file format definition can specify which of the two chunks appear first the data file. Generally, the CTOC chunk is placed at the front of the file to reduce the seek and read times required to access it. During authoring time, an application might place the CTOC chunk at the end of the file, so it can be expanded as elements are added to the CGRP chunk. <P>
<b>Chapter </b><P>
<h1>Multimedia File Formats</h1><P>
This chapter describes the multimedia file formats. Most of these file formats are based on the Resource Interchange File Format (RIFF), described in Chapter 2. <P>
This chapter describes the following file formats:<P>
* Bundle File Format (BND)<P>
* Device Independent Bitmap File Format (DIB) <P>
* RIFF DIB File Format (RDIB)<P>
* Musical Instrument Digital Interface File Format (MIDI)<P>
* RIFF MIDI File Format (RMID)<P>
* Palette File Format (PAL)<P>
* Rich Text Format (RTF)<P>
* Waveform Audio File Format (WAVE)<P>
<h2>Bundle File Format</h2><P>
The Bundle (BND)  format contains a series of RIFF chunks or other multimedia files. The BND file is defined as follows:<P>
&lt;BND-file&gt; &#221; RIFF('BND' &lt;CTOC-chunk&gt; &lt;CGRP-chunk&gt; )<P>
The <b>&lt;CTOC-chunk&gt;</b> and <b>&lt;CGRP-chunk&gt;</b> formats are defined in "Compound File Structure," in Chapter 2, "Resource Interchange File Format."<P>
Each compound file element must be capable of standing alone as an independent file. An element may not be a random chunk (except the RIFF chunk, indicating a RIFF file) or random binary data (unless the binary data is supposed to be treated as a file).<P>
<h2>Device Independent Bitmap File Format</h2><P>
The Device Independent Bitmap (DIB) format represents bitmap images in a device-independent manner. Bitmaps can be represented at 1, 4, and 8 bits per pixel, with a palette containing colors represented in 24 bits. Bitmaps can also be represented at 24 bits per pixel without a palette and in a run-length encoded format.
File formats;Device-Independent Bitmap (DIB)DIB files;Multimedia Windows<P>
This documentation describes three types of DIB files:<P>
* Windows version 3.0 device-independent bitmap files<P>
* OS/2 Presentation Manager version 1.2 device-independent bitmap files<P>
* RIFF device-independent bitmap files<P>
The Windows 3.0 and Presentation Manager 1.2 DIBs are similar, so they are discussed together. <P>
<h3>Overview of DIB Structure</h3><P>
Windows 3.0 and Presentation Manager 1.2 DIB files consist of the following sequence of data structures:DIB files;structure<P>
* A file header<P>
* A bitmap information header<P>
* A color table<P>
* An array of bytes that defines the bitmap bits<P>
The following sections describe each of these structures.<P>
<h3>Bitmap File Header</h3><P>
The bitmap file header contains information about the type, size, and layout of a device-independent bitmap (DIB) file. In both the Windows 3.0 and Presentation Manager 1.2 DIBs, it is defined as a BITMAPFILEHEADER data structure:BITMAPFILEHEADER data structure;in DIB fileDIB files;bitmap file header<P>
typedef struct tagBITMAPFILEHEADER {<BR>
 WORD bfType;<BR>
 DWORD bfSize;<BR>
 WORD bfReserved1;<BR>
 WORD bfReserved2;<BR>
 DWORD bfOffBits;<BR>
} BITMAPFILEHEADER;<P>
The following table describes the fields.
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Field</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>bfType</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the file type. It must consist of the character sequence BM (WORD value 0x4D42).</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>bfSize</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the file size in bytes.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>bfReserved1</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Reserved. Must be set to zero.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>bfReserved2</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Reserved. Must be set to zero.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>bfOffBits</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the byte offset from the BITMAPFILEHEADER structure to the actual bitmap data in the file.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h3>Bitmap Information Header</h3><P>
The BITMAPINFO and BITMAPCOREINFO data structures define the dimensions and color information for Windows 3.0 and Presentation Manager 1.2 DIBs, respectively. They are defined as follows:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Windows 3.0 DIB</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Presentation Manager 1.2 DIB</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>typedef struct tagBITMAPINFO {<BR>
  BITMAPINFOHEADER bmiHeader;<BR>
  RGBQUAD bmiColors[1];<BR>
} BITMAPINFO;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>typedef struct _BITMAPCOREINFO {<BR>
  BITMAPCOREHEADER  bmciHeader;<BR>
  RGBTRIPLE bmciColors[1];<BR>
} BITMAPCOREINFO;<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
These structures are essentially alike, and this section discusses them simultaneously. Each field name for the Windows BITMAPINFO structure is followed by the corresponding field name for the Presentation Manager BITMAPCOREINFO 1.2 structure, in parentheses.<P>
The following table describes the fields.
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Windows (PM) Field</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>bmiHeader </b>(<b>bmciHeader</b>)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies information about the dimensions and color format of the DIB. The BITMAPINFOHEADER and BITMAPCOREHEADER data structures are described in the next section.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>bmiColors</b> (<b>bmciColors</b>)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the DIB color table. The RGBQUAD and RGBTRIPLE data structures are described in &quot;Bitmap Color Table,&quot; later in this chapter.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h4>Information Header Structures</h4><P>
The BITMAPINFOHEADER and BITMAPCOREHEADER structures contain information about the dimensions and color format of Windows 3.0 and Presentation Manager 1.2 DIBs, respectively. They are defined as follows:<BR>
DIB files;bitmap information headerBITMAPINFOHEADER data structure;in DIB file
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Windows 3.0 DIB</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Presentation Manager 1.2 DIB</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>typedef struct tagBITMAPINFOHEADER { <BR>
  DWORD biSize;<BR>
  DWORD biWidth;<BR>
  DWORD biHeight;<BR>
  WORD biPlanes;<BR>
  WORD biBitCount;<BR>
  DWORD biCompression;<BR>
  DWORD biSizeImage;<BR>
  DWORD biXPelsPerMeter;<BR>
  DWORD biYPelsPerMeter;<BR>
  DWORD biClrUsed;<BR>
  DWORD biClrImportant;<BR>
 } BITMAPINFOHEADER;<BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>typedef struct tagBITMAPCOREHEADER {<BR>
  DWORD bcSize;<BR>
  WORD bcWidth;<BR>
  WORD bcHeight;<BR>
  WORD bcPlanes;<BR>
  WORD bcBitCount;<BR>
 } BITMAPCOREHEADER;<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
Because these structures are essentially alike, except for the added fields in the Windows 3.0 structure, this section discusses them simultaneously. Each field name for the Windows structure is followed by the corresponding field name for the Presentation Manager structure, in parentheses.<P>
<h5><b>Common Fields</b></h5><P>
The following fields are present in both the Windows 3.0 and Presentation Manager 1.2 formats:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Windows (PM) Field</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>biSize</b> (<b>bcSize</b>)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the number of bytes required by the BITMAPINFOHEADER structure. You can use this field to distinguish between Windows 3.0 and Presentation Manager 1.2 DIBs.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>biWidth</b> (<b>bcWidth</b>)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the width of the DIB in pixels.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>biHeight</b> (<b>bcHeight</b>)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the height of the DIB in pixels.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>biPlanes</b> (<b>bcPlanes</b>)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the number of planes for the target device. Must must be set to 1.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wBitCount</b> (<b>bcBitCount</b>)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the number of bits-per-pixel. See &quot;Interpreting the Color Table,&quot; later in this section, for more information.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h5><b>Windows Fields</b></h5><P>
The following fields are present only in the Windows 3.0 BITMAPINFOHEADER structure:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Field</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>biCompression</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the type of compression for a compressed bitmap. It can be one of the following values:</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Value Meaning</b><BR>
BI_RGB Specifies that the bitmap is not compressed.<BR>
BI_RLE4 Specifies a run-length encoded format for bitmaps with 4 bits-per-pixel. The compression format is a two-byte format consisting of a count byte followed by two word-length color indexes.<BR>
BI_RLE8 Specifies a run-length encoded format for bitmaps with 8 bits-per-pixel. The compression format is a two-byte format consisting of a count byte followed by a color-index byte.<BR>
<BR>
See &quot;Windows 3.0 Bitmap Compression Formats&quot; later in this document for information about the encoding schemes.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>biSizeImage</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the size in bytes of the image.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>biXPelsPerMeter</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the horizontal resolution in pixels per meter of the target device for the bitmap. An application can use this value to select a bitmap from a resource group that best matches the characteristics of the current device.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>biYPelsPerMeter</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the vertical resolution in pixels per meter of the target device for the bitmap.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>biClrUsed</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the number of color values in the color table actually used by the bitmap. Possible values follow.<BR>
<b>Value Result</b><BR>
0 Bitmap uses the maximum number of colors corresponding to the value of the <b>wBitCount field</b>.<BR>
Nonzero If the <b>wBitCount</b> value is less than 24, the <b>biClrUsed</b> value indicates the actual number of colors which the graphics engine or device driver will access.<BR>
<BR>
If the <b>wBitCount</b> value is 24, the <b>biClrUsed</b> value indicates the size of the reference color table used to optimize performance of Windows color palettes.<BR>
<BR>
If the bitmap is a &quot;packed&quot; bitmap (that is, a bitmap in which the bitmap array immediately follows the BITMAPINFO header and which is referenced by a single pointer), the <b>biClrUsed</b> field must be set to 0 or to the actual size of the color table. See &quot;Interpreting the Color Table,&quot; later in this section, for more information on how this field affects the interpretation of the color table.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>biClrImportant</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the number of color indexes that are considered important for displaying the bitmap. If this value is 0, then all colors are important.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h3>Bitmap Color Table</h3><P>
The color table is a collection of 24-bit RGB values. There are as many entries in the color table as there are colors in the bitmap. The color table isn't present for bitmaps with 24 color bits because each pixel is represented by 24-bit RGB values in the actual bitmap data area. Color table;and bitmap colors[bitmap]DIB files;bitmap color tableRGBQUAD data structure;in DIB fileRGBTRIPLE data structure;in DIB file<P>
<h4>Color Table Structure</h4><P>
The color table for Windows 3.0 and Presentation Manager 1.2 DIBs consists of an array of RGBQUAD and RGBTRIPLE structures, respectively. These structures are defined as follows: 
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Windows 3.0 DIB</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Presentation Manager 1.2 DIB</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>typedef struct tagRGBQUAD {<BR>
  BYTE rgbBlue;<BR>
  BYTE rgbGreen;<BR>
  BYTE rgbRed;<BR>
  BYTE rgbReserved;<BR>
 } RGBQUAD;<BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2> typedef struct tagRGBTRIPLE {<BR>
  BYTE rgbtBlue;<BR>
  BYTE rgbtGreen;<BR>
  BYTE rgbtRed;<BR>
 } RGBTRIPLE;<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
Because these structures are essentially alike, this section discusses them simultaneously. Each field name for the Windows RGBQUAD structure is followed by the corresponding field name for the Presentation Manager RGBTRIPLE structure, in parentheses.<P>
<h4>Order of Colors</h4><P>
The colors in the table should appear in order of importance. This can help a device driver render a bitmap on a device that cannot display as many colors as there are in the bitmap. If the DIB is in Windows 3.0 format, the driver can use the <b>biClrImportant</b> field of the BITMAPINFOHEADER structure to determine which colors are important.
Color table;color orderRGB values;color table intensityColor table;color intensityBITMAPINFOHEADER data structure;bitmap color importance<P>
<h4>Field Descriptions</h4><P>
The RGBQUAD (RGBTRIPLE) structure contains the following fields:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Windows (PM) Field</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>rgbBlue</b> (<b>rgbtBlue</b>)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the blue intensity.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>rgbGreen</b> (<b>rgbtGreen</b>)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the green intensity.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>rgbRed</b> (<b>rgbtRed</b>)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the red intensity.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>rgbReserved</b> (no PM equivalent)<BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Not used. Must be set to 0.<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h4>Locating the Color Table</h4><P>
An application can use the <b>biSize</b> (<b>bcSize</b>) field of the BITMAPINFOHEADER (BITMAPCOREHEADER) structure to locate the color table. Each of the following statements assigns the pColor variable the byte offset of the color table from the beginning of the file:BITMAPINFOHEADER data structure;color table locationBITMAPCOREHEADER data structure;color table location<P>
// Windows 3.0 DIB <BR>
pColor = (LPSTR)pBitmapInfo + (WORD)pBitmapInfo-&gt;biSize<BR>
<BR>
// Presentation Manager 1.2 DIB <BR>
pColor = (LPSTR)pBitmapCoreInfo + (WORD)pBitmapCoreInfo-&gt;bcSize<P>
<h4>Interpreting the Color Table</h4><P>
The <b>biSize </b>(<b>bcSize</b>) field of the BITMAPINFOHEADER (BITMAPCOREHEADER) structure specifies how many bits define each pixel and specifies the maximum number of colors in the bitmap. Its value affects your interpretation of the color table.
BITMAPINFOHEADER data structure;color definitionBITMAPCOREHEADER data structure;color definitionColor table;defining number of colors<P>
The <b>biSize </b>(<b>bcSize</b>) field can have any of the following values:
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Value</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Meaning</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The bitmap is monochrome, and the color table contains two entries. Each bit in the bitmap array represents a pixel. If the bit is clear, the pixel is displayed with the color of the first entry in the color table. If the bit is set, the pixel has the color of the second entry in the table.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>4</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The bitmap has a maximum of 16 colors. Each pixel in the bitmap is represented by a four-bit index into the color table.<BR>
For example, if the first byte in the bitmap is 0x1F, then the byte represents two pixels. The first pixel contains the color in the second table entry, and the second pixel contains the color in the 16th table entry.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>8</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The bitmap has a maximum of 256 colors. Each pixel in the bitmap is represented by a byte-sized index into the color table. For example, if the first byte in the bitmap is 0x1F, then the first pixel has the color of the thirty-second table entry. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>24</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The bitmap has a maximum of 224 colors. The <b>bmiColors</b> (<b>bmciColors</b>) field is NULL, and each three bytes in the bitmap array represent the relative intensities of red, green, and blue, respectively, of a pixel.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h5><b>Note on Windows DIBs</b></h5><P>
For Windows 3.0 DIBs, the field of the BITMAPINFOHEADER structure specifies the number of color indexes in the color table actually used by the bitmap. If the <b>biClrUsed </b>field is set to 0, the bitmap uses the maximum number of colors corresponding to the value of the field.<P>
<h3>Bitmap Data</h3><P>
The bits in the array are packed together, but each line of pixels, or scan line, must be zero-padded to end on a LONG boundary. When the bitmap is in memory, segment boundaries can appear anywhere in the bitmap. The origin of the bitmap is the lower-left corner. The following section discusses compression formats for the Windows 3.0 bitmap data.<P>
<h3>Windows 3.0 Bitmap Compression Formats</h3><P>
Windows supports run-length encoded formats for compressing 4- and 8-bit bitmaps. Compression reduces the disk and memory storage required for the bitmap. The following sections describe the compression formats.
DIB files;Windows compression formats<P>
<h4>Compression of 8-Bit-Per-Pixel DIBs</h4><P>
When the <b>biCompression</b> field is set to BI_RLE8, the bitmap is compressed using a run-length encoding format for an 8-bit bitmap. This format uses two modes:Compression format;8-bit DIBs[eight]Run-length encoded format;8-bit DIBs[eight]<P>
* Encoded mode<P>
* Absolute mode<P>
Both modes can occur anywhere throughout a single bitmap.<P>
<h5><b>Encoded Mode</b></h5><P>
Encoded mode consists of two bytes. The first byte specifies the number of consecutive pixels to be drawn using the color index contained in the second byte.
Encoded mode;8-bit DIBs[eight]<P>
Also, the first byte of the pair can be set to zero to indicate an escape that denotes an end of line, end of bitmap, or a delta. The interpretation of the escape depends on the value of the second byte of the pair. In encoded mode, the second byte has a value of 0 to 2.<P>
The following table shows the meaning of the second byte:
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Second Byte</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b> Meaning</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>0</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>End of line.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>End of bitmap.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>2</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Delta. The two bytes following the escape contain unsigned values indicating the horizontal and vertical offset of the next pixel from the current position.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h5><b>Absolute Mode</b></h5><P>
Absolute mode is signalled by the first byte set to zero and the second byte set to a value between 03H and FFH.<P>
The second byte represents the number of bytes that follow, each of which contains the color index of a single pixel.
Absolute mode;8-bit DIBs[eight]<P>
Each run must be aligned on a word boundary.<P>
The following example shows the hexadecimal values of an 8-bit RLE bitmap. Under "Expanded Data," the two-digit values represent a color index for a single pixel.
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Compressed Data</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Expanded Data</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>03 04<BR>
05 06 <BR>
00 03 45 56 67 00 <BR>
02 78 <BR>
00 02 05 01 <BR>
02 78 <BR>
00 00 <BR>
09 1E <BR>
00 01</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>04 04 04<BR>
06 06 06 06 06<BR>
45 56 67<BR>
78 78<BR>
move 5 right and 1 down<BR>
78 78<BR>
end of line<BR>
1E 1E 1E 1E 1E 1E 1E 1E 1E <BR>
end of RLE bitmap<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h4>Compression of 4-Bit-Per-Pixel DIBs</h4><P>
When the field is set to BI_RLE4, the bitmap is compressed using a run-length encoding format for a 4-bit bitmap. This format uses two modes:Compression format;4-bit DIBs[four]<P>
* Encoded mode<P>
* Absolute mode<P>
<h5><b>Encoded Mode</b></h5><h5>Encoded mode;4-bit DIBs[four]</h5><P>
In encoded mode, the first byte of the pair contains the number of pixels to be drawn using the color indexes in the second byte.<P>
The second byte contains two color indexes, one in its high-order nibble (that is, its low-order four bits) and one in its low-order nibble.<P>
The first of the pixels is drawn using the color specified by the high-order nibble, the second is drawn using the color in the low-order nibble, the third is drawn with the color in the high-order nibble, and so on, until all the pixels specified by the first byte have been drawn.<P>
Also, the first byte of the pair can be set to zero to indicate an escape that denotes an end of line, end of bitmap, or a delta. The interpretation of the escape depends on the value of the second byte of the pair. In encoded mode, the second byte has a value from 00H to 02H.<P>
<h5><b>Absolute Mode</b></h5><h5>Absolute mode;4-bit DIBs[four]</h5><P>
In absolute mode, the first byte contains zero, the second byte contains the number of color indexes that follow, and subsequent bytes contain color indexes in their high- and low-order nibbles, one color index for each pixel.<P>
Each run must be aligned on a word boundary.<P>
The end-of-line, end-of-bitmap, and delta escapes valid for BI_RLE8 also apply to BI_RLE4.<P>
The following example shows the hexadecimal values of a 4-bit RLE bitmap. Under "Expanded Data," the one-digit values represent a color index for a single pixel.
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Compressed Data</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Expanded Data</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>03 04<BR>
05 06 <BR>
00 06 45 56 67 00 <BR>
04 78 <BR>
00 02 05 01 <BR>
04 78 <BR>
00 00 <BR>
09 1E <BR>
00 01</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>0 4 0<BR>
0 6 0 6 0 <BR>
4 5 5 6 6 7<BR>
7 8 7 8<BR>
move 5 right and 1 down<BR>
7 8 7 8<BR>
end of line<BR>
1 E 1 E 1 E 1 E 1<BR>
end of RLE bitmap<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h2>RIFF Device-Independent Bitmap File Format</h2><P>
This document describes two types of RIFF Device-Independent Bitmap (RDIB) format:<P>
* A simple RDIB consisting of a DIB file enclosed in a RIFF chunk.<P>
* An extended RDIB that allows the creation of more complex bitmaps<P>
To ensure that the maximum number of programs will accept an RDIB file, programs that adopt the extended RDIB format should also accept simple RDIB files. Both formats are described in the following sections.<P>
<h3>Simple RDIB Format</h3><P>
The simple RDIB format consists of a Windows 3.0 or Presentation Manager 1.2 DIB enclosed in a 'RIFF' chunk. Enclosing the DIB in a 'RIFF' chunk allows the file to be consistently identified; for example, an 'INFO' list can be included in the file. <P>
The simple 'RDIB' form is defined as follows, using the standard RIFF form definition notation:DIB files;RDIB formatRIFF files;RDIB formRDIB file format File formats;RIFF Device-Independent Bitmap (RDIB)RDIB files;description<P>
&lt;RDIB-form&gt; &#221;  RIFF ( 'RDIB' data( &lt;DIB-data&gt; )) <P>
The <b>&lt;DIB-data&gt;</b> format is defined in "Device Independent Bitmap File Format," earlier in this chapter.<P>
<h3>Extended RDIB Format</h3><P>
The extended RDIB format, designed to incorporate enhancements such as compression, is defined as follows:<P>
&lt;RDIB-form&gt; &#221;<BR>
   RIFF('RDIB'<BR>
      &lt;bmhd-ck&gt;    // Bitmap header chunk<BR>
      [ &lt;pal-file&gt; |   // Internal palette chunk<BR>
        &lt;XPAL-ck&gt;   ]   // External palette chunk<BR>
      &lt;bitmap-data&gt; )   // Bitmap data<P>
The <b>&lt;pal-file&gt;</b> chunk can be any of the palette-file formats discussed in "Palette File Format," later in this chapter. The <b>&lt;bmhd-ck&gt;</b>, <b>&lt;XPAL-chunk&gt;</b>, and <b>&lt;bitmap-data&gt;</b> are described in the following sections.<P>
<h4>Bitmap Header Chunk</h4><P>
The <b>&lt;bmhd-ck&gt;</b> bitmap header chunk is defined as follows:<P>
&lt;bmhd-chunk&gt; &#221; bmhd( struct {<BR>
 DWORD dwMemSize;    // If <b>dwPelFormat</b> is 'data', only these<BR>
 DWORD dwPelFormat;   // four fields are present.<BR>
 WORD wTransType;<BR>
 DWORD dwTransVal;<BR>
 DWORD dwHdrSize;    // Fields from <b>dwHdrSize</b> forward match<BR>
 DWORD dwWidth;    // the Windows BITMAPINFOHEADER <BR>
 DWORD dwHeight;    // structure, though some fields can<BR>
 WORD dwPlanes;    // contain new values.<BR>
 WORD dwBitCount; <P>
 DWORD dwCompression; <BR>
 DWORD dwSizeImage;<BR>
 DWORD dwXPelsPerMeter;<BR>
 DWORD dwYPelsPerMeter;<BR>
 DWORD dwClrUsed;<BR>
 DWORD dwClrImportant;<BR>
 } )<P>
If the <b>dwCompression</b> field equals BI_RGB or BI_RLE8 or BI_RLE4, then the extended RDIB has the same bitmap format as a simple RDIB.<P>
Each pixel format defines the orientation, or position of the bitmap origin. Windows bitmaps (identified by a value of 'data' in the <b>dwPelFormat</b> field) have the origin at the bottom left. By default, the other formats have the origin at the top left.
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Field</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwMemSize</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Equal to the size of the bitmap bits if the bits are uncompressed. For RDIBs with <b>dwPelFormat</b> equal to 'data,' <b>dwMemSize</b> has one of the following values:<BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Image Type</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Field Value</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Non-RLE</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Same as <b>dwSizeImage</b> value</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>8-bit RLE</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Size as an uncompressed, 8-bit image</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>4-bit RLE</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Size as an uncompressed, 4-bit image<BR>
<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwPelFormat</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies a FOURCC code defining the pixel format of the bitmap data. The bitmap data is stored in a chunk (or chunks) that has the same chunk ID as is contained in <b>dwPelFormat</b>. The compression scheme and pixel depth of the bitmap data are recorded in the <b>dwCompression</b> and <b>dwBitCount</b> fields. The current bitmap data values are as follows:<BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Value</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Bitmap Data Location and Format</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>'data'</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Bitmap data is stored in a 'data' chunk using the format defined for Windows 3.0 device independent bitmaps (DIBs). An application can display the bitmap properly even if the fields after (and including) <b>dwMemSize</b> are ignored.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>'palb'</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Bitmap data is stored in a 'palb' chunk. The pixel format is one of the Windows 3.0 RGB palettized formats (1 to 8 bpp, depending on the value of the <b>dwBitCount</b> field).</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>'rgbb'</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Bitmap data is stored in a 'rgbb' chunk. Pixel format is packed, unpalettized RGB represented at 16, 24, or 32 bits per pixel. The following shows the ordering of the RGB bits for each pixel-depth value. The first extra bit (if present) is the high-order bit.<BR>
<BR>
<b>dwBitCount Extra Red Green Blue</b><BR>
15 1 5 5 5<BR>
16 0 5 6 5<BR>
24 0 8 8 8<BR>
32 8 8 8 8<BR>
<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>'yuvb'</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Bitmap data is stored in a 'yuvb' chunk. Pixel format is packed, unpalettized YUV. The exact pixel format is currently undefined. By the time this draft is final, the pixel format will be defined similarly to the 'rgbb' definition.<BR>
<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wTransType</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the type of transparency representation, if any, used for this image. This is normally used for either image overlay applications, where one image may be visually on top of another, and all pels of the transparency color should not be drawn. Examples include sprites, clip art and motion video overlay. Wherever the transparency color occurs in the picture, the background should be visible.<BR>
This information is stored with the image, so that multiple images that use the same color map may all have different transparency color. There are 5 different values for the transparency variable. These are:<BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Value</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Result</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BITT_NONE <BR>
(0x0000)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>No pels are considered transparent in this image.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BITT_MAPINDEX <BR>
(0x0001)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>One of the color map/palette entries should be considered the transparency color. All instances of this pel should NOT be drawn, and the existing background should be allowed to show through.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BITT_SINGLECOLOR (0x0002)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>A single RGB or YUV value is considered transparent and should not be drawn.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BITT_BITPLANE  <BR>
(0x0003)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>An individual bit plane is considered transparent, and all pels that have that bit or bits &quot;on&quot; should not be drawn.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BITT_MULTILEVEL <BR>
(0x0004)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>A set of bits indicate multiple levels of transparency or opacity. This is usually used with 32-bit RGB, where the high 8 bits indicate transparency.<BR>
<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwTransVal</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>These bytes allow the image definition to indicate the exact information about the transparent color. The information is dependent on the value of the <b>wTransType</b> as follows:<BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>wTransType</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>dwTransVal Contents</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BITT_NONE </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Not used.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BITT_MAPINDEX</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies a palette index, either 0 through 16 or 0 through 255, depending on the number of palette entries.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BITT_SINGLECOLOR</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies an RGB or YUV value (2 to 4 bytes in size, depending on the pixel format specified by <b>dwPelFormat</b>). All pels that match <b>dwTransVal</b> should be considered transparent.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BITT_BITPLANE</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies a bit mask identifying the bits used to indicate a transparent pel. Any pel that has this set of bits set is totally transparent. This allows multiple colors to be considered transparent. This method works for palettized images; in this case, the value refers to a map entry that is considered transparent.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BITT_MULTILEVEL</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies bits to use for transparency levels. These bits act as a mask on every pel, and each pel can be matched to the mask to determine the transparency level for the pel.<BR>
For example, if <b>dwTransVal</b> has value 0xFF000000, then there are 256 levels of transparency. Each pel can be evaluated against the mask. If the pel has a value FFxxxxxx, then it is fully transparent. If the pel has a value 00xxxxxx, then it is fully visible. If the pel has a value 7Fxxxxxx, then the pel is half visible.<BR>
<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwHdrSize</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the size of the data portion of the <b>&lt;bmhdr&gt;</b> chunk. This is always 40, the size of the BITMAPINFOHEADER structure.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwWidth</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the width of the DIB in pixels.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwHeight</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the height of the DIB in pixels.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wPlanes</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the number of planes. This value is normally 1, but it can be 3 or 4 for 24-bit RGB and 32-bit RGB images, respectively. In a multiplane DIB, each color component (for example, red, green, and blue) is stored as a separate plane, and each plan is stored in a separate bitmap data chunk. For example, in a 3-plane, 24-bit 'rgbb' bitmap, the red colors are stored in one 'rgbb' chunk, the green colors in a second 'rgbb' chunk, and the blue colors in a third 'rgbb' chunk.<BR>
Allowing the separate RGB planes to be compressed independently can dramatically improve the compression ratio. The <b>wPlanes</b> value must be 1 if <b>dwPelFormat</b> equals 'data'.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wBitCount</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the number of bits per pixel. If the <b>dwPelFormat</b> field equals 'data', this field must contain values compatible with the Windows 3.0 DIB definition.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwCompression</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the type of compression for a compressed bitmap. It can be one of the following values:<BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Value</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Meaning</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BI_NONE<BR>
(0xFFFF0000)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies that the bitmap is not compressed. Pixel values are <i>not</i> padded to four-byte boundaries.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BI_RGB <BR>
(0x00000000)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies that the bitmap is an uncompressed, 1-, 4-, 8-, or a 24-bit image. For 24-bit images, the palette is optional. Bitmap bits are represented as defined by Windows 3.0 for BI_RGB DIBs. The <b>dwPelFormat</b> field must be set to 'data'.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BI_RLE8 <BR>
(0x00000001)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies a run-length encoded, compressed bitmap (as defined by Windows 3.0 BI_RLE8 DIBs). The palette is required. The <b>dwPelFormat</b> field must be set to 'data'.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BI_RLE4 <BR>
(0x00000002)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies a run-length encoded, compressed bitmap (as defined by Windows 3.0 BI_RLE4 DIBs). The palette is required. The <b>dwPelFormat</b> field must be set to 'data'.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BI_PACK <BR>
(0xFFF0001)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies a simple PACKBITS byte compression scheme consisting of one-byte counts followed by byte data, in the form:<BR>
&lt;count byte <i>n</i>&gt;&lt;data byte1&gt;&lt;data byte2&gt;...&lt;data byte <i>n</i>&gt;<BR>
&lt;count byte <i>n</i>&gt;&lt;data byte to repeat&gt;<BR>
The high-order bit of the count byte <i>n</i> is a decision bit:<BR>
<BR>
<i><b>n</i> Value Data Representation</b><BR>
<i>n</i> &lt; 0x80 A run of <i>n</i>+1 non-repeating bytes follows.<BR>
<i>n</i> &gt; 0x80 Data byte is repeated (<i>n</i>-0x80+1) times.<BR>
<i>n</i> = 0x80 Reserved.<BR>
<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BI_TRANS <BR>
(0xFFFF0002)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies transitional compression, using a table of byte transitions or sequences. See &quot;Transitional Compression,&quot; following this table.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BI_CCC<BR>
(0xFFFF0003)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies CCC compression, a method involving encoding each 4-by-4 block of the image using two colors. See &quot;CCC Compression,&quot; following this table.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>BI_JPEGN (0xFFFF0004)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>To be defined later, when the ISO completes the official specification.<BR>
<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwSizeImage</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the size in bytes of the compressed image.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwXPelsPerMeter</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the horizontal resolution in pixels per meter of the target device for the bitmap. An application can use this value to select a bitmap from a resource group that best matches the characteristics of the current device. This field is set to zero if unused.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwYPelsPerMeter</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the vertical resolution in pixels per meter of the target device for the bitmap. This field is set to zero if unused.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwClrUsed</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the number of palette entries actually used by the bitmap. Possible values follow.<BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Value</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Result</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>0</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Bitmap uses the maximum number of colors corresponding to the value of the <b>wBitCount</b> field.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Nonzero</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>If the <b>wBitCount</b> is less than 24, <b>dwClrUsed</b> specifies the actual number of colors which the graphics engine or device driver will access.<BR>
If the <b>wBitCount</b> field is set to 24, <b>dwClrUsed</b> specifies the size of the reference color table used to optimize performance of Windows color palettes.<BR>
<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwClrImportant</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the number of color indexes that are considered important for displaying the bitmap. If this value is 0, then all colors are important.<BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h4>Transitional Compression</h4><P>
If the <b>dwCompression</b> field is set to BI_TRANS, the data is transitionally compressed using a table of byte transitions or sequences. Values in the data indicate a table position to start at, and the table provides continuing references to other table positions. Transitional compression applies only to eight-bit data, either from an eight-bit palettized image or from a multi-plane image in which each color component is represented in eight bits.<P>
The table consists of up to 256 16-byte rows at the beginning of the data section of the object. Nibbles (half-bytes) in the data section indicate an offset into a table row, at which location is stored the actual byte value. The actual value then becomes the row applicable to the next data nibble. The transitional encoding scheme is described more fully in a separate IBM document.<P>
In transitional compression, the data section is a two-part compound object having the following items:<P>
* A transition table<P>
* The compressed image data<P>
The transition table consists of an integer indicating the table size in bytes and a table of 16-byte rows. The first byte in each row is a row number and the next 15 are transition values. Rows are in descending sequence. The image is compressed according to the following rules:<P>
* Data is in nibbles (half-bytes) or in nibble-pairs (successive half-bytes which may cross a byte boundary).<P>
* The first byte is a nibble-pair. It is the first byte of the image and also the first row number.<P>
* Following a nibble-pair is a series of transition nibbles (1-15) ended by a terminator (0). Each transition nibble indicates an offset in the current row at which the next byte in the image is found; this value is also the next row number. <P>
* The terminator indicates that the next image byte is not in the table, but instead in the following nibble-pair. This value is also the next row number. <P>
* If the picture has an odd number of nibbles (i.e., it ends in the first half of the last byte), an extra zero nibble is included.<P>
<h4>CCC Compression</h4><P>
TBD.<P>
<h4>Palette Chunk</h4><P>
A PLT chunk represents a color table and consists of a valid PAL file. The PAL file format is defined in "Palette File Format," later in this chapter.<P>
<h4>External Palette Chunk</h4><P>
Instead of a PLT chunk, an RDIB may contain an XPLT chunk, which indicates that the bitmap's palette is stored outside the bitmap. The palette might be stored in a separate file or as a separate compound file element. The XPLT chunk indicates the name and location of the external palette chunk and is defined as follows:<P>
&lt;XPLT-chunk&gt; &#221; XPLT(&lt;fccLocation:FOURCC&gt; &lt;szPaletteName::ZSTR&gt;)<P>
The <b>fccLocation</b> contains one of the following FOURCC values specifying the location of the external chunk:
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>fccLocation Value</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Chunk Location</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>'full'</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Palette is located in an external file, and the <b>szPaletteName</b> value specifies a complete filename with path.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>'file'</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Palette is located in an external file, and the <b>szPaletteName</b> value specifies a filename without path.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>'elem'</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Palette is located in the same compound file containing the DIB. The <b>szPaletteName</b> value specifies the name of the compound file element.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
The <b>szPaletteName</b> consists of a null-terminated string (ZSTR) containing the name of the external chunk containing the palette.<P>
<h4>Bitmap Data Chunk</h4><P>
The &lt;bitmap-data&gt; contains bitmap data in the format specified by the <b>biPelFormat</b> field of the &lt;bmhd-chunk&gt;.<P>
<h2>MIDI and RIFFMIDI File Formats</h2><P>
The Musical Instrument Digital Interface (MIDI) file format represents a Standard MIDI File, as defined by the MIDI Manufacturers Association. A MIDI file contains commands instructing instruments to play specific notes and perform other operations. File formats;Musical Instrument Digital Interface (MIDI)<P>
The specifications for MIDI and MIDI files can be obtained from the following organization:MIDI files;specifications<P>
International MIDI Association (IMA)<BR>
5316 W. 57th Street<BR>
Los Angeles, CA 90056<BR>
(213) 649-6434.<P>
The 'RMID' format consists of a standard MIDI file enclosed in a RIFF chunk. Enclosing the MIDI file in a 'RIFF' chunk allows the file to be consistently identified; for example, an 'INFO' list can be included in the file. RIFF files;RMID formatFile formats;RIFF Musical Instrument Digital Interface (MIDI)RMID file formatMIDI files;RMID format<P>
The 'RMID' form is defined as follows, using the standard RIFF form definition:<P>
&lt;RMID-form&gt; &#221; RIFF ('RMID' data( &lt;MIDI-data&gt; ))<P>
The &lt;MIDI-data&gt; is equivalent to a Standard MIDI File.<P>
<h2>Palette File Format</h2><P>
The Palette (PAL) File Format represents a logical palette, which is a collection of colors represented as RGB values. There are two types of PAL formats:<P>
* A simple PAL format<P>
* An extended PAL format<P>
<h3>Simple PAL Format</h3><P>
The simple PAL format is defined as follows:Palette files;PAL file formatPAL file formatFile formats;Palette (PAL)<P>
RIFF('PAL' data( &lt;palette:LOGPALETTE&gt; ))<P>
LOGPALETTE is the Windows 3.0 logical palette structure, defined as follows:Palette files;logical palette structureLOGPALETTE data structure;with palette filesLogical palette structure<P>
typedef struct tagLOGPALETTE {<BR>
  WORD    palVersion;<BR>
  WORD    palNumEntries;<BR>
  PALETTEENTRY  palPalEntry[];<BR>
} LOGPALETTE;<P>
The LOGPALETTE structure fields are as follows:
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Field </b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>palVersion</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the Windows version number for the structure.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>palNumEntries</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the number of palette color entries.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>palPalEntry[]</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies an array of PALETTEENTRY data structures that define the color and usage of each entry in the logical palette.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
The colors in the palette entry table should appear in order of importance. This is because entries earlier in the logical palette are most likely to be placed in the system palette.<P>
The PALETTEENTRY data structure specifies the color and usage of an entry in a logical color palette. The structure is defined as follows:PALETTEENTRY data structure;with palette filesPalette files;setting intensityRGB values;palette intensity<P>
typedef struct tagPALETTEENTRY {<BR>
  BYTE  peRed;<BR>
  BYTE  peGreen;<BR>
  BYTE  peBlue;<BR>
  BYTE  peFlags;<BR>
} PALETTEENTRY;<P>
The PALETTEENTRY structure fields are as follows:
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Field</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>peRed</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the intensity of red for the palette entry color.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>peGreen</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the intensity of green for the palette entry color.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>peBlue</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the intensity of blue for the palette entry color.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>peFlags</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies how the palette entry is to be used.</FONT></TD>
</TR>
</TABLE>
<P>
<h3>Extended PAL Format</h3><P>
The extended PAL format includes the following:<P>
* A palette-header chunk <P>
* A data chunk containing an RGB palette (consisting of a LOGPALETTE structure) or some other palette type, including YUV and XYZ palettes.<P>
For an RGB palette, the extended PAL format is represented as follows:<P>
RIFF('PAL' plth( &lt;palette-header&gt; ) data( &lt;LOGPALETTE-data&gt; ))<P>
For a YUV palette, the extended PAL format is represented as follows:<P>
RIFF('PAL' plth( &lt;palette-header&gt; ) yuvp( &lt;YUV-LOGPALETTE-data&gt; ))<P>
Both the <b>&lt;LOGPALETTE-data&gt;</b> and <b>&lt;YUV-LOGPALETTE-data&gt;</b> use the Windows 3.0 LOGPALETTE structure, described in "Simple PAL Format," earlier in this section. The <b>&lt;YUV-LOGPALETTE-data&gt;</b> contains YUV values instead of RGB values.<P>
The 'plth' chunk is defined as follows:<P>
&lt;plth-ck&gt; &#221; PLT( struct {<BR>
  DWORD dwMapType;<BR>
  WORD wWhite;    // Fields from this point on are<BR>
  WORD wBlack;    // optional. If they are included<BR>
  WORD wBorder;   // but not used, set them to 0xFFFF.<BR>
  WORD wRegisteredMap;<BR>
  WORD wCustomBase;   // If an application encounters a<BR>
  WORD wCustomCnt;   // 'PLT' chunk smaller than shown<BR>
  WORD wRsvBase;   // here, it should treat the missing<BR>
  WORD wRsvCount;   // fields as unused.<BR>
  WORD wArtBase;<BR>
  WORD wArtCnt;<BR>
  WORD wNumIntense;<BR>
} )<P>
The structure fields are described in the following:
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Field</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwMapType</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>FOURCC code specifying the type of palette. Currently, the following palette types are identified:<BR>
<BR>
<b>Code Description</b><BR>
'data' Specifies an RGB palette. Data chunk contains a LOGPALETTE structure.<BR>
'yuvp' Specifies a YUV palette. Data chunk contains a YUV palette.<BR>
'xyzp' Specifies an XYZ palette. Data chunk contains a XYZ palette.<BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wWhite<BR>
wBlack</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specify palette-map indices corresponding to the closest value of white and black. These identify the pair of colors with the best contrast for use in cursors, calibration, etc. These values are usually changed if the palette changes. Ignore these fields if they contain 0xFFFF.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wBorder</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the index of the palette entry to be used for any display-border regions, if supported by the display device. Ignore this field if it contains 0xFFFF.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wRegisteredMap</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies how many palette entries correspond to a registered color map. Registered entries are stored at the front of the palette. Ignore this field if it contains 0xFFFF. </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Registered map entries are always stored at the beginning of the palette, so <b>wRegisteredMap</b> also indicates the index of the first custom color in the palette. Registered color maps include predefined palettes for general use, forest/nature, or seasides. Currently defined values are the following:<BR>
<BR>
<b>Value Description</b><BR>
PAL_UNREGISTERED (0xFFFF)<BR>
Color map does not contain colors from a registered color map.<BR>
PAL_VGA (0x0000)<BR>
Color map contains the standard 16 VGA colors.<BR>
PAL_AVC198 (0x0001)<BR>
Standard AVC 198-entry palette.<BR>
<BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wCustomBase</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the index of the first custom color of the palette. The beginning of the palette contains the entries of the registered map, so <b>wCustomBase</b> also indicates the number of entries in the registered palette. Map entries starting with <b>wCustomBase</b> comprise additional custom colors used in the bitmap. Ignore this value if <b>wRegisteredPalette</b> is PAL_UNREGISTERED, or if <b>wCustomBase</b> contains 0xFFFF.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wCustomCnt</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the number of custom colors in the palette.  Ignore this value if <b>wRegisteredPalette</b> is PAL_UNREGISTERED, or if this field contains 0xFFFF.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wRsvBase</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the index of the first reserved color of the palette. Reserved colors are those reserved for menus, text, and other screen elements. Reserved colors must be stored contiguously. Ignore this field if it contains 0xFFFF.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wRsvCnt</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the number of reserved entries. Ignore this field if it contains 0xFFFF.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wArtBase</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the index of the first art color of the palette. Art colors are colors used for text and drawing. Art colors consist of a number of hues, each of which has multiple intensities. The various intensities are used for anti-aliasing, a method of using different shades of a color to improve the quality of images displayed on low-resolution devices.<BR>
For example, if the first art color is red anti-aliased to black with three intensities, the first three entries in the palette would be dark red, medium red, and bright red. The art colors constitute an array, and all hues have the same number of intensities. The user can set both the number of hues and the number of intensities. Ignore these fields if they contain 0xFFFF.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wArtCnt</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the number of art colors. Ignore this field if it contains 0xFFFF.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wNumIntense</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the number of palette entries reserved for the anti-aliased levels of a given art color. This field must be present if <b>wArtBase</b> is present. Ignore this field if it contains 0xFFFF.<BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h2>Rich Text Format (RTF)</h2><P>
The Rich Text Format (RTF) is a standard method of encoding formatted text and graphics using only 7-bit ASCII characters. Formatting includes different font sizes, faces, and styles, as well as paragraph alignment, justification, and tab control.
Rich Text Format file formatRTF file formatFile formats;Rich Text Format (RTF)<P>
RTF is described in the <i>Microsoft Word Technical Reference: For Windows and OS/2</i>, published by Microsoft Press.<P>
<h2>Waveform Audio File Format (WAVE)</h2><P>
This section describes the Waveform format, which is used to represent digitized sound.
RIFF forms;WAVEWaveform files;WAVE formatFile formats;Waveform Audio (WAVE)<P>
The WAVE form is defined as follows. Programs must expect (and ignore) any unknown chunks encountered, as with all RIFF forms. However, <b>&lt;fmtck&gt;</b> must always occur before <b>&lt;wavedata&gt;</b>, and both of these chunks are mandatory in a WAVE file.<P>
&lt;WAVE-form&gt; &#221; <BR>
  RIFF( 'WAVE' <BR>
    &lt;fmt-ck&gt;     // Format<BR>
    [&lt;fact-ck&gt;]     // Fact chunk<BR>
    [&lt;cue-ck&gt;]     // Cue points<BR>
    [&lt;playlist-ck&gt;]    // Playlist<BR>
    [&lt;assoc-data-list&gt;]   // Associated data list<BR>
    &lt;wave-data&gt;  )     // Wave data<P>
The WAVE chunks are described in the following sections.<P>
<h3>WAVE Format Chunk</h3><P>
The WAVE format chunk <b>&lt;fmt-ck&gt;</b> specifies the format of the <b>&lt;wave-data&gt;</b>. The <b>&lt;fmt-ck&gt;</b> is defined as follows:<P>
&lt;fmt-ck&gt; &#221;  fmt( &lt;common-fields&gt; <BR>
      &lt;format-specific-fields&gt; )<BR>
<BR>
&lt;common-fields&gt; &#221;<BR>
  struct<BR>
   { <BR>
   WORD wFormatTag;    // Format category<BR>
    WORD wChannels;    // Number of channels<BR>
    DWORD dwSamplesPerSec;   // Sampling rate<BR>
    DWORD dwAvgBytesPerSec;  // For buffer estimation<BR>
    WORD wBlockAlign;   // Data block size<BR>
   }<P>
The fields in the <b>&lt;common-fields&gt;</b> chunk are as follows:
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Field</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wFormatTag</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>A number indicating the WAVE format category of the file. The content of the <b>&lt;format-specific-fields&gt;</b> portion of the 'fmt' chunk, and the interpretation of the waveform data, depend on this value. <BR>
You must register any new WAVE format categories. See &quot;Registering Multimedia Formats&quot; in Chapter 1, &quot;Overview of Multimedia Specifications,&quot; for information on registering WAVE format categories.<BR>
&quot;Wave Format Categories,&quot; following this section, lists the currently defined WAVE format categories.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wChannels</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The number of channels represented in the waveform data, such as 1 for mono or 2 for stereo.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwSamplesPerSec</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The sampling rate (in samples per second) at which each channel should be played.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwAvgBytesPerSec</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The average number of bytes per second at which the waveform data should be transferred. Playback software can estimate the buffer size using this value.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wBlockAlign</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The block alignment (in bytes) of the waveform data. Playback software needs to process a multiple of <b>wBlockAlign</b> bytes of data at a time, so the value of <b>wBlockAlign</b> can be used for buffer alignment.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
The <b>&lt;format-specific-fields&gt;</b> consists of zero or more bytes of parameters. Which parameters occur depends on the WAVE format category-see the following section for details. Playback software should be written to allow for (and ignore) any unknown <b>&lt;format-specific-fields&gt;</b> parameters that occur at the end of this field.
Samples, setting bits per sample<P>
<h3>WAVE Format Categories</h3><P>
The format category of a WAVE file is specified by the value of the <b>wFormatTag</b> field of the 'fmt' chunk. The representation of data in <b>&lt;wave-data&gt;</b>, and the content of the <b>&lt;formatspecificfields&gt;</b> of the 'fmt' chunk, depend on the format category.
Waveform files;format categories <P>
The currently defined open non-proprietary WAVE format categories are as follows:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>wFormatTag Value</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Format Category</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>WAVE_FORMAT_PCM (0x0001)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Microsoft Pulse Code Modulation (PCM) format<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
The following are the registered proprietary WAVE format categories:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>wFormatTag Value</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Format Category</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>IBM_FORMAT_MULAW (0x0101)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>IBM mu-law format</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>IBM_FORMAT_ALAW (0x0102)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>IBM a-law format</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>IBM_FORMAT_ADPCM (0x0103)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>IBM AVC Adaptive Differential Pulse Code Modulation format<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
The following sections describe the Microsoft WAVE_FORMAT_PCM format.<P>
<h4>Pulse Code Modulation (PCM) Format</h4><P>
If the <b>wFormatTag</b> field of the <b>&lt;fmt-ck&gt;</b> is set to WAVE_FORMAT_PCM, then the waveform data consists of samples represented in pulse code modulation (PCM) format. For PCM waveform data, the <b>&lt;format-specific-fields&gt;</b> is defined as follows:<P>
&lt;PCM-format-specific&gt; &#221; <BR>
  struct<BR>
   {<BR>
   WORD wBitsPerSample;   // Sample size<BR>
   }<P>
The <b>wBitsPerSample</b> field specifies the number of bits of data used to represent each sample of each channel. If there are multiple channels, the sample size is the same for each channel.<P>
For PCM data, the <b>wAvgBytesPerSec</b> field of the 'fmt' chunk should be equal to the following formula rounded up to the next whole number:<P>
 <P>
The <b>wBlockAlign</b> field should be equal to the following formula, rounded to the next whole number:Data blocks;aligning waveform<P>
 <P>
<h5><b>Data Packing for PCM WAVE Files</b></h5><P>
In a single-channel WAVE file, samples are stored consecutively. For stereo WAVE files, channel 0 represents the left channel, and channel 1 represents the right channel. The speaker position mapping for more than two channels is currently undefined. In multiple-channel WAVE files, samples are interleaved.<P>
The following diagrams show the data packing for a 8-bit mono and stereo WAVE files:
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Sample 1</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Sample 2</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Sample 3</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Sample 4</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>Channel 0</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Channel 0</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Channel 0</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Channel 0</FONT></TD>
</TR>
</TABLE>
<P>
<b>Data Packing for 8-Bit Mono PCM</b>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Sample 1</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Sample 2</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>Channel 0<BR>
(left)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Channel 1<BR>
(right)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Channel 0<BR>
(left)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Channel 0<BR>
(right)<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<b>Data Packing for 8-Bit Stereo PCM</b><P>
The following diagrams show the data packing for 16-bit mono and stereo WAVE files:
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Sample 1</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Sample 2</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>Channel 0<BR>
<BR>
low-order byte</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Channel 0<BR>
<BR>
high-order byte</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Channel 0<BR>
<BR>
low-order byte</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Channel 0<BR>
<BR>
high-order byte<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<b>Data Packing for 16-Bit Mono PCM</b>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Sample 1</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>Channel 0<BR>
(left)<BR>
low-order byte</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Channel 0<BR>
(left)<BR>
high-order byte</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Channel 1<BR>
(right)<BR>
low-order byte</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Channel 1<BR>
(right)<BR>
high-order byte<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<b>Data Packing for 16-Bit Stereo PCM</b><P>
<h5><b>Data Format of the Samples</b></h5><P>
Each sample is contained in an integer <i>i</i>. The size of <i>i</i> is the smallest number of bytes required to contain the specified sample size. The least significant byte is stored first. The bits that represent the sample amplitude are stored in the most significant bits of <i>i</i>, and the remaining bits are set to zero.<P>
For example, if the sample size (recorded in <b>nBitsPerSample</b>) is 12 bits, then each sample is stored in a two-byte integer. The least significant four bits of the first (least significant) byte is set to zero.
Amplitude, setting waveform<P>
The data format and maximum and minimums values for PCM waveform samples of various sizes are as follows:
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Sample Size</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Data Format</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Maximum Value</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Minimum Value</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>One to eight bits</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Unsigned integer</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>255 (0xFF)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>0</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>Nine or more bits</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Signed integer <i>i</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Largest positive value of <i>i</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Most negative value of <i>i<BR>
</i><BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
For example, the maximum, minimum, and midpoint values for 8-bit and 16-bit PCM waveform data are as follows:
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Format</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Maximum Value</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Minimum Value</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Midpoint Value</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>8-bit PCM</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>255 (0xFF)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>0</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>128 (0x80)</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>16-bit PCM</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>32767 (0x7FFF)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>-32768 (-0x8000)</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>0<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h5><b>Examples of PCM WAVE Files</b></h5><P>
Example of a PCM WAVE file with 11.025 kHz sampling rate, mono, 8 bits per sample:<P>
RIFF( 'WAVE'  fmt(1, 1, 11025, 11025, 1, 8)<BR>
      data( &lt;wave-data&gt; ) )<P>
Example of a PCM WAVE file with 22.05 kHz sampling rate, stereo, 8 bits per sample:<P>
RIFF( 'WAVE'  fmt(1, 2, 22050, 44100, 2, 8)<BR>
      data( &lt;wave-data&gt; ) )<P>
Example of a PCM WAVE file with 44.1 kHz sampling rate, mono, 20 bits per sample:<P>
RIFF( 'WAVE'   INFO(INAM(&quot;O Canada&quot;Z))<BR>
      fmt(1, 1, 44100, 132300, 3, 20)<BR>
      data( &lt;wave-data&gt; ) )<P>
<h3>Storage of WAVE Data</h3><P>
The <b>&lt;wave-data&gt;</b> contains the waveform data. It is defined as follows:<P>
&lt;wave-data&gt; &#221;  { &lt;data-ck&gt; | &lt;data-list&gt; }<BR>
<BR>
&lt;data-ck&gt;  &#221;  data( &lt;wave-data&gt; )<BR>
<BR>
&lt;wave-list&gt; &#221;  LIST( 'wavl' {   &lt;data-ck&gt; |   // Wave samples<BR>
          &lt;silence-ck&gt; }... ) // Silence<BR>
<BR>
&lt;silence-ck&gt; &#221;  slnt( &lt;dwSamples:DWORD&gt; )  // Count of<BR>
             // silent samples<P>
<i><b>Note:  </b></i>The 'slnt' chunk represents silence, not necessarily a repeated zero volume or baseline sample. In 16-bit PCM data, if the last sample value played before the silence section is a 10000, then if data is still output to the D to A converter, it must maintain the 10000 value. If a zero value is used, a click may be heard at the start and end of the silence section. If play begins at a silence section, then a zero value might be used since no other information is available. A click might be created if the data following the silent section starts with a nonzero value.<P>
<h3>FACT Chunk</h3><P>
The <b>&lt;fact-ck&gt;</b> fact chunk stores important information about the contents of the WAVE file. This chunk is defined as follows:<P>
&lt;fact-ck&gt; &#221; fact( &lt;dwFileSize:DWORD&gt; )   // Number of samples<P>
The "fact" chunk is required if the waveform data is contained in a "wavl" LIST chunk and for all compressed audio formats. The chunk is not required for PCM files using the "data" chunk format.<P>
The &quot;fact&quot; chunk will be expanded to include any other information required by future WAVE formats. Added fields will appear following the <b>&lt;dwFileSize&gt;</b> field. Applications can use the chunk size field to determine which fields are present.<P>
<h3>Cue-Points Chunk</h3><P>
The <b>&lt;cue-ck&gt;</b> cue-points chunk identifies a series of positions in the waveform data stream. The <b>&lt;cue-ck&gt;</b> is defined as follows:<P>
&lt;cue-ck&gt; &#221;   cue(  &lt;dwCuePoints:DWORD&gt;  // Count of cue points<BR>
       &lt;cue-point&gt;... )  // Cue-point table<BR>
<BR>
&lt;cue-point&gt; &#221;  struct {<BR>
      DWORD  dwName; <BR>
      DWORD  dwPosition;<BR>
      FOURCC fccChunk;<BR>
      DWORD  dwChunkStart;<BR>
      DWORD  dwBlockStart; <BR>
      DWORD  dwSampleOffset;<BR>
     }<P>
The <b>&lt;cue-point&gt;</b> fields are as follows:
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Field</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwName</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the cue point name. Each <b>&lt;cue-point&gt;</b> record must have a unique <b>dwName</b> field.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwPosition</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the sample position of the cue point. This is the sequential sample number within the play order. See &quot;Playlist Chunk,&quot; later in this document, for a discussion of the play order.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>fccChunk</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the name or chunk ID of the chunk containing the cue point.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwChunkStart</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the file position of the start of the chunk containing the cue point. This is a byte offset relative to the start of the data section of the 'wavl' LIST chunk.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwBlockStart</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the file position of the start of the block containing the position. This is a byte offset relative to the start of the data section of the 'wavl' LIST chunk.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwSampleOffset</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the sample offset of the cue point relative to the start of the block. <BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h4>Examples of File Position Values</h4><P>
The following table describes the <b>&lt;cue-point&gt;</b> field values for a WAVE file containing multiple 'data' and 'slnt' chunks enclosed in a 'wavl' LIST chunk:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Cue Point Location</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Field</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Value</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>In a 'slnt' chunk</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>fccChunk</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>FOURCC value 'slnt'.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>dwChunkStart</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>File position of the 'slnt' chunk relative to the start of the data section in the 'wavl' LIST chunk.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>dwBlockStart</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>File position of the data section of the 'slnt' chunk relative to the start of the data section of the 'wavl' LIST chunk.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>dwSampleOffset</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sample position of the cue point relative to the start of the 'slnt' chunk.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>In a PCM 'data' chunk</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>fccChunk</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>FOURCC value 'data'.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>dwChunkStart</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>File position of the 'data' chunk relative to the start of the data section in the 'wavl' LIST chunk.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>dwBlockStart</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>File position of the cue point relative to the start of the data section of the 'wavl' LIST chunk. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>dwSampleOffset</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Zero value.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>In a compressed 'data' chunk</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>fccChunk</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>FOURCC value 'data'.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>dwChunkStart</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>File position of the start of the 'data' chunk relative to the start of the data section of the 'wavl' LIST chunk.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>dwBlockStart</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>File position of the enclosing block relative to the start of the data section of the 'wavl' LIST chunk. The software can begin the decompression at this point.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>dwSampleOffset</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sample position of the cue point relative to the start of the block.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
The following table describes the <b>&lt;cue-point&gt;</b> field values for a WAVE file containing a single 'data' chunk:
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Cue Point Location</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Field</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Value</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>Within PCM data</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>fccChunk</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>FOURCC value 'data'.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>dwChunkStart</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Zero value.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>dwBlockStart</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Zero value.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>dwSampleOffset</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sample position of the cue point relative to the start of the 'data' chunk.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>In a compressed 'data' chunk</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>fccChunk</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>FOURCC value 'data'.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>dwChunkStart</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Zero value.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>dwBlockStart</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>File position of the enclosing block relative to the start of the 'data' chunk. The software can begin the decompression at this point.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>dwSampleOffset</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sample position of the cue point relative to the start of the block.</FONT></TD>
</TR>
</TABLE>
<P>
<h3>Playlist Chunk</h3><P>
The <b>&lt;playlist-ck&gt;</b> playlist chunk specifies a play order for a series of cue points. The <b>&lt;playlist-ck&gt;</b> is defined as follows:<P>
&lt;playlist-ck&gt; &#221;  plst(<BR>
      &lt;dwSegments:DWORD&gt; // Count of play segments<BR>
      &lt;play-segment&gt;... ) // Play-segment table<BR>
<BR>
&lt;play-segment&gt; &#221;  struct {<BR>
       DWORD dwName;<BR>
       DWORD dwLength;<BR>
       DWORD dwLoops;<BR>
      }<P>
The <b>&lt;play-segment&gt;</b> fields are as follows:
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Field</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwName</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the cue point name. This value must match one of the names listed in the <b>&lt;cue-ck&gt;</b> cue-point table.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwLength</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the length of the section in samples.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwLoops</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the number of times to play the section.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h3>Associated Data Chunk</h3><P>
The <b>&lt;assoc-data-list&gt;</b> associated data list provides the ability to attach information like labels to sections of the waveform data stream. The <b>&lt;assoc-data-list&gt;</b> is defined as follows:<P>
&lt;assoc-data-list&gt; &#221;  LIST( 'adtl'<P>
          &lt;labl-ck&gt;   // Label<P>
         &lt;note-ck&gt;   // Note<P>
         &lt;ltxt-ck&gt;   // Text with data length<P>
         &lt;file-ck&gt; )   // Media file<P>
&lt;labl-ck&gt; &#221;    labl( &lt;dwName:DWORD&gt;<P>
         &lt;data:ZSTR&gt; )<P>
&lt;note-ck&gt; &#221;    note( &lt;dwName:DWORD&gt;<P>
         &lt;data:ZSTR&gt; ) <P>
&lt;ltxt-ck&gt; &#221;    ltxt( &lt;dwName:DWORD&gt; <P>
         &lt;dwSampleLength:DWORD&gt; <P>
         &lt;dwPurpose:DWORD&gt;<P>
         &lt;wCountry:WORD&gt;<P>
         &lt;wLanguage:WORD&gt;<P>
         &lt;wDialect:WORD&gt;<P>
         &lt;wCodePage:WORD&gt;<P>
         &lt;data:BYTE&gt;... )<P>
&lt;file-ck&gt; &#221;    file( &lt;dwName:DWORD&gt;<P>
         &lt;dwMedType:DWORD&gt;<P>
         &lt;fileData:BYTE&gt;...)<P>
<h4>Label and Note Information</h4><P>
The 'labl' and 'note' chunks have similar fields. The 'labl' chunk contains a label, or title, to associate with a cue point. The 'note' chunk contains comment text for a cue point. The fields are as follows:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Field</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwName</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the cue point name.  This value must match one of the names listed in the &lt;cue-ck&gt; cue-point table.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>data</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies a NULL-terminated string containing a text label (for the 'labl' chunk) or comment text (for the 'note' chunk).<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h4>Text with Data Length Information</h4><P>
The "ltxt" chunk contains text that is associated with a data segment of specific length. The chunk fields are as follows:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Field</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwName</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the cue point name.  This value must match one of the names listed in the &lt;cue-ck&gt; cue-point table.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwSampleLength</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the number of samples in the segment of waveform data.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwPurpose</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the type or purpose of the text. For example, <b>dwPurpose</b> can specify a FOURCC code like 'scrp' for script text or 'capt' for close-caption text.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wCountry</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the country code for the text. See &quot;Country Codes&quot; in Chapter 2, &quot;Resource Interchange File Format,&quot; for a current list of country codes.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wLanguage</b>,<BR>
<b>wDialect</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specify the language and dialect codes for the text. See &quot;Language and Dialect Codes&quot; in Chapter 2, &quot;Resource Interchange File Format,&quot; for a current list of language and dialect codes.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wCodePage</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the code page for the text. <BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h4>Embedded File Information</h4><P>
The 'file' chunk contains information described in other file formats (for example, an 'RDIB' file or an ASCII text file). The chunk fields are as follows:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Field</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwName</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the cue point name.  This value must match one of the names listed in the &lt;cue-ck&gt; cue-point table.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>dwMedType</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the file type contained in the <b>fileData</b> field. If the <b>fileData</b> section contains a RIFF form, the <b>dwMedType</b> field is the same as the RIFF form type for the file. <BR>
This field can contain a zero value.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>fileData</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Contains the media file.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<b>Chapter </b><P>
<h1>Media Control Interface</h1><P>
The Media Control Interface (MCI) is a high-level command control interface to multimedia devices and resource files. MCI provides applications with device-independent capabilities for controlling audio and visual peripherals. Your application can use MCI to control any multimedia device, including audio playback and recording, as well as videodisc and videotape players.<P>
MCI provides a standard command set for playing and recording multimedia devices and resource files. Developers creating multimedia applications are encouraged to use this high-level command interface rather than the low-level functions specific to each platform. The MCI command set acts as a platform-independent layer that sits between multimedia applications and the underlying system software. <P>
The command set is extensible in two ways:<P>
* Developers can incorporate new multimedia devices and file formats in the MCI command set by creating new MCI drivers to interpret the commands.<P>
* New commands and command options can be added to support special features or functions required by new multimedia devices or file formats.<P>
<h2>MCI Command Strings</h2><P>
Using MCI, an application can control multimedia devices using simple command strings like open, play, and close. The MCI commands provide a generic interface to different multimedia devices, reducing the number of commands a developer needs to learn. A multimedia application might even accept MCI commands from an end user and pass them unchanged to the MCI driver, which parses the command and performs the appropriate action.<P>
A set of basic commands is supported by all MCI devices. Developers can also define MCI commands and command options specific to a particular multimedia device or file format. These device-specific commands and command options are needed only when the basic command set does not support a feature specific to the device or file format.<P>
<h3>Example of MCI Command Use</h3><P>
The following example shows a series of MCI commands that play track 6 of an audio compact disc:<P>
open cdaudio<BR>
set cdaudio time format tmsf<BR>
play cdaudio from 6 to 7<BR>
close cdaudio<P>
The next example shows a similar series of MCI commands that play the first 10,000 samples of a waveform audio file:<P>
open c:\mmdata\purplefi.wav type waveaudio alias finch<BR>
set finch time format samples<BR>
play finch from 1 to 10000 wait<BR>
close finch<P>
Notice the following:<P>
* The same basic commands (<b>open</b>, <b>play</b>, and <b>close</b>) are used with both devices.<P>
* The <b>open</b> command for the "waveaudio" device includes a filename specification. The "waveaudio" device is a compound device (one associated with a media element), while the "cdaudio" device is a simple device (one without an associated media element).<P>
* The <b>set</b> commands both specify time formats, but the time format options for the "cdaudio" device are different from those used with the "waveaudio" device.<P>
* The parameters used with the <b>from</b> and <b>to</b> flags are appropriate to the respective device. For the "cdaudio" device, the parameters specify a range of tracks; for the "waveaudio" device, the parameters specify a range of samples.<P>
<h3>Categories of MCI Command Strings</h3><h3>Media Control Interface;commands defined</h3><P>
MCI command strings divide into the following categories:<P>
* <i>System commands</i> are interpreted directly by MCI rather than being relayed to a device.<P>
* <i>Required commands</i> are recognized by all MCI devices. If a device does not support a required command, it can return "unsupported function" in response to the message. Media Control Interface;required commands@defined<P>
* <i>Basic commands</i> are optional commands. If a device uses a basic command, it must respond to all options for that command. If a device does not use a basic command, it can return "unrecognized command" in response to the message. Media Control Interface;basic commands@defined<P>
* <i>Extended commands</i> are specific to a device type or device class; for example, videodisc players. These commands contain both unique commands and extensions to the required and basic commands. &lt;$IMedia Control Interface;extended commands@defined<P>
<h3>Command Syntax Conventions</h3><P>
This chapter uses the following documentation conventions:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Convention</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>bold</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>MCI command or flag keyword.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><i>italics</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Command parameter to be replaced with a valid string, number, or rectangle specification.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&quot;quotes&quot;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Parameter text to be typed exactly as shown.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>[ brackets ]</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Optional flags or parameters<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h3></h3><h3>Media Control Interface;commands definedSystem Commands</h3><P>
The following list summarizes the system commands. MCI supports these commands directly rather than passing them to MCI devices. Media Control Interface;system messages@defined
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Message</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>sound</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Play system sounds defined in a system setup file.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>sysinfo</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns information about MCI devices.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h3>Required Commands</h3><P>
The following list summarizes the required commands. All devices recognize these messages. If a device does not support a required command, it can return "unsupported function" in response to the message. 
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Message</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>capability</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Obtains the capabilities of a device.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>close</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Closes the device.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>info</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Obtains textual information from a device.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>open</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Initializes the device.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>status</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns various status information from the device.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h3>Basic Commands</h3><P>
The following list summarizes the basic commands. MCI devices are not required to recognize these commands.  If the device does not recognize a basic command, it can return "unrecognized command" in response to the message.
Media Control Interface;basic messages@defined
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Message</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>load</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Recalls data from a disk file.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>pause</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Stops playing.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>play</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Starts transmitting output data.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>record</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Starts recording input data.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>resume</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Resumes playing or recording from a paused state.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>save</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Saves data to a disk file.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>seek</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Seeks forward or backward.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>set</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the operating state of the device.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>status</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Obtains status information about the device. (The flags for this command supplement the flags for the command in the required command group.)</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>stop</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Stops playing.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h3>Extended Commands</h3><P>
MCI devices can have additional commands or extend the definition of the required and basic commands. While some extended commands only apply to a specific device driver most of them apply to all devices of a particular type. For example, the MIDI sequencer command set extends the <b>set</b> command to add time formats needed by MIDI sequencers.You can find descriptions of extended commands in the command tables in this chapter.<P>
<h4>Extended Commands Reserved for Future Use</h4><P>
The following commands can be defined as extended commands. With the exception of the <b>delete</b> command, they are not currently defined for any MCI devices.
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Message</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>copy</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Copies data to the Clipboard. Parameters and flags for this message vary according to the  selected device.   </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>cut</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Moves data from the MCI element to the Clipboard. Parameters and flags for this message vary according to the selected device. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>delete</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Removes data from the MCI element. Parameters and flags for this message vary according to the selected device.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h3>Creating a Command String</h3><P>
There are three components associated with each command string: the command, the name or ID of the device receiving the command, and the command arguments. A command string has the following form: Media Control Interface;command string defined<P>
<i>command    device_name    arguments</i><P>
These components contain the following information:<P>
* The <i>command</i> includes a command from the system, required, basic, or extended command set. Examples of commands include <b>open</b>, <b>close</b>, and <b>play</b>.<P>
* The <i>device_name</i> designates the target of the <i>command</i>. MCI accepts the names of MCI device types and names of media elements for the <i>device_name</i>. An example of a device name is "cdAudio".<P>
* The <i>arguments</i> specify the flags and parameters used by the <i>command</i>. Flags are key words recognized by the MCI command, and parameters are variables  associated with the MCI command or flag. Parameters specify variable data values such as filenames, track or frame numbers, or speed values. You can use the following data types for the parameters in a string command: <P>
* Strings-String data types can be delimited by leading and trailing white space or by matching quotation marks. If MCI encounters a single (unmatched) quotation mark, it ignores the quotation mark. To embed a quote in string, use two quotes (&quot;&quot;). To specify an empty string, you can use double quotes (&quot;&quot;) for the string. <P>
* Signed long integers-Signed long integer data types are delimited by leading and trailing white space. Unless otherwise specified, integers can be positive or negative. If using negative integers, do not embed white space between the negative sign and the first digit.<P>
* Rectangle-Rectangle data types are an ordered list of four signed integer values. White space delimits this data type as well as separates each integer in the list. <P>
 For example, the <b>play</b> command uses the arguments "<b>from</b> <i>position</i> <b>to</b> <i>position</i>" to specify starting and ending points for the playback. The <b>from</b> and <b>to</b> arguments are flags, and the two <i>position</i> values are parameters.<P>
For example, the following command string instructs the CD audio player "cdaudio" to play from the start of the waveform to position 500: <P>
play cdaudio from 0 to 500<P>
Unspecified command arguments assume a default value. For example, if the flag <i>from</i> was unspecified in the previous example, the audio player would start playing at the current position. <P>
<h3>About MCI Device Types</h3><P>
Your application identifies an MCI device by specifying an MCI <i>device type</i>. A device type indicates the physical type of device. The following table lists the currently defined MCI device types:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Device Type</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>cdaudio1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>CD audio player</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>dat</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Digital audio tape player</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>digitalvideo</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Digital video in a window (not GDI based)</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>other</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Undefined MCI device</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>scanner</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Image scanner</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>sequencer1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>MIDI sequencer</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>vcr</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Videotape recorder or player</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>videodisc1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Videodisc player</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>waveaudio1</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Audio device that plays digitized waveform files<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
1An extended command set is provided for these devices.<P>
If you have a particular device type installed more than once, the device type names in the system setup file have integers appended to them. This creates unique names for each MCI device type entry. For example, if the "cdaudio" device type is installed twice, the names "cdaudio1" and "cdaudio2" are used to create unique names for each occurrence of the device type. Each name usually refers to a different CD audio player in the system.
Device types;drivers<P>
<h2>Using MCI Command Strings</h2><P>
The tables at the end of this chapter describe command strings for the MCI devices. The following sections describe commonly used command strings. <P>
<h3>Opening a Device</h3><h3>Media Control Interface;opening a device</h3><P>
Before using a device, you must initialize it with the <b>open</b> command. The number of devices you can have open depends on the amount of available memory. The <b>open</b> command has the following syntax:<P>
<b>open</b> <i>device_name</i> [<b>shareable</b>] [<b>type</b> <i>device_type</i>] [<b> alias</b> <i>alias </i>]<P>
 The parameters for the <b>open</b> command are:
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Parameters</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><i>device_name</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the destination device or MCI element name (filename).</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>shareable</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Allows applications to share a common device or device element.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>type</b> <i>device_type</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the device when the <i>device_name</i> refers to an MCI element.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>alias</b> <i>alias</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies an alternate name for the device.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
MCI classifies device drivers as <i>compound</i> and <i>simple</i>. Compound device drivers use a <i>device element</i>-a media element associated with a device-during operation. For most compound device drivers, the device element is the source or destination data file. For file elements, the element name references a file and its path.<P>
Simple device drivers do not require a device element for playback. For example, compact disc audio device drivers are simple device drivers.<P>
<h4>Opening Simple Devices</h4><P>
Simple devices require only the <i>device_name</i> for operation. You don't need to provide any additional information (such as a name of a data file) to open these devices. For these devices, substitute the name of a device type obtained from the system setup file. For example, you can open a videodisc device with the following command:<P>
open videodisc1<P>
<h4>Opening Compound Devices</h4><P>
There are three ways to open a compound device:<P>
* By specifying just the device type<P>
* By specifying both the element name and the device type<P>
* By specifying just the element name<P>
To determine the capabilities of a device, you can open a device by specifying only the device type. When opened this way, most compound devices will let you determine their capabilities and close them. For example, you can open the sequencer with the following command:<P>
open sequencer<P>
To associate a device element with a particular device, you must specify the element name and device type. In the <b>open</b> command, substitute the element name for the <i>device_name</i>, add the <b>type</b> flag, and substitute the name of the device you want to use for <i>device_type</i>. This combination lets your application specify the MCI device it needs to use. For example, you can open a device element of the waveaudio device with the following command:<P>
open  right.wav  type  waveaudio<P>
To associate a default MCI device with a device element, you can specify just an element name. In this case, MCI uses the filename extension of the element name to select the device type.<P>
<h4>Using the Shareable Flag</h4><P>
The <b>shareable</b> flag lets multiple applications or tasks concurrently access the same device (or element) and device instance. <P>
If your application opens a device or device element without the <b>shareable</b> flag, no other application can access it simultaneously. If your application opens a device or device element as shareable, other applications can also access it by also opening it as shareable. The shared device or device element gives each application the ability to change the parameters governing the operating state of the device or device element. Each time that a device or device element is opened as shareable, a unique device ID is returned (even though the device IDs refer to the same instance)<P>
If you make a device or device element shareable, your application should not make any assumptions about the state of a device. When working with shared devices, your application might need to compensate for changes made by other applications using the same services. <P>
If a device can service only one application or task it will fail an open with the <b>shareable</b> flag. <P>
While most compound device elements are not shareable, you can open multiple elements (where each element is unique), or you can open a single element multiple times. If you open a single file element multiple times, MCI creates an independent instance for each open device. Each file element opened within a task must have a unique name. The <b>alias</b> flag described in the next section lets you use a unique name for each element.<P>
<h4>Using the Alias Flag</h4><P>
The <b>alias</b> flag specifies an alternate name for the given device. The alias provides a shorthand notation for compound devices with lengthy pathnames. If your application creates a device alias, it must use the alias rather than the device name for all subsequent references.<P>
<h4>Opening New Device Elements</h4><P>
To create a new device element for a task such as capturing a sound using waveform recording, specify <b>new</b> as a <i>device_name</i>. MCI does not save a new file element until you save it with the <b>save</b> command. When creating a new file, you must include a device alias with the <b>open</b> command. The following commands open a new waveaudio device element, start and stop recording, save the file element, and close the device element:<P>
open new type waveaudio alias capture<BR>
record capture<BR>
stop capture<BR>
save capture orca.wav<BR>
close capture <P>
<h3>Closing a Device</h3><h3>Media Control Interface;closing a device</h3><P>
The <b>close</b> command releases access to a device or device element. To help MCI manage the devices, your application must explicitly close each device or device element when it is finished with it.<P>
<h3>Shortcuts and Variations for MCI Commands</h3><P>
The MCI string interface lets you use several shortcuts when working with MCI devices. <P>
<h4>Using All as a Device Name</h4><P>
You can specify <b>all</b> as a <i>device_name</i> for any command that does not return information. When you specify <b>all</b>, the command is sent to all devices opened by your application. For example, "close all" closes all open devices and "play all" starts playing all devices opened by the task. Because MCI sends the commands to each device, there is a delay between when the first device receives the command and when the last device receives the command.<P>
<h4>Combining the Device Type and Device Element Name</h4><P>
You can eliminate the <b>type</b> flag in the <b>open</b> command if you combine the device type with the device element name. MCI recognizes this combination when you use the following syntax:<P>
<i>device_type</i><i>element_name</i><P>
The exclamation mark separates the device type from the element name. The following example opens the right.wav element with the waveaudio device:<P>
open waveaudio!right.wav<P>
<h4>Automatic Open</h4><P>
If MCI cannot identify the <i>device_name</i> as an already open device, MCI tries to automatically open the specified device. Automatic open does not let your application specify the <b>type</b> flag. If the device type is not supplied, MCI determines the device type from the element (filename) extensions listed in the system setup file. If you want to use a specific device, you can combine the device type name with the device element name using the exclamation mark. <P>
Only the command-string interface supports automatic open. Automatic open will fail for device-specific commands. For example, a command to unlock the front panel of a videodisc player will fail an automatic open because this capability is specific to the particular videodisc player. <P>
A device that was opened using the automatic open feature will not respond to a command that uses <b>all</b> as a device name.<P>
<h4>Automatic Close</h4><P>
MCI automatically closes any device automatically opened using the command-string interface. MCI closes a device when the command completes, when you abort the command, when you request notification with a subsequent command, or when MCI detects a failure.
Automatic open/close<P>
<h3>Using Wait and Notify Flags</h3><P>
Normally, MCI commands return to the user immediately, even if it takes several minutes to complete the action initiated by the command. For example, after a VCR device receives a rewind command, it returns before the tape has finished rewinding. You can use either of the following required MCI flags to modify this default behavior:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Flag</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>notify</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Directs the device to send an MM_MCINOTIFY message to a window when the requested action is complete. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>wait</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Directs the device to wait until the requested action is complete before returning to the application.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h4>Using the Notify Flag</h4><h4>Media Control Interface;callbacks@sending messages to</h4><P>
The <b>notify</b> flag directs the device to post an MM_MCINOTIFY message when the device completes an action. Your application must have a window procedure to process the MM_MCINOTIFY message for notification to have any effect. While the results of a notification are application-dependent, the application's window procedure can act upon four possible conditions associated with the notify message:<P>
* Notification will occur when the notification conditions are satisfied.<P>
* Notification can be superseded.<P>
* Notification can be aborted.<P>
* Notification can fail.<P>
A successful notification occurs when the conditions required for initiating the callback are satisfied and the command completed without interruption. <P>
A notification is superseded when the device has a notification pending and you send it another notify request. When a notification is superseded, MCI resets the callback conditions to correspond to the notify request of the new command. <P>
A notification is aborted when you send a new command that prevents the callback conditions set by a previous command from being satisfied. For example, sending the stop command cancels a notification pending for the "play to 500" command. If your command interrupts a command that has a notification pending, and your command also requests notification, MCI will abort the first notification immediately and respond to the second notification normally.<P>
A notification fails if a device error occurs while a device is executing the MCI command. For example, MCI posts this message when a hardware error occurs during a play command.<P>
<h3>Obtaining Information From MCI Devices</h3><P>
Every device responds to the <b>capability</b>, <b>status</b>, and<b> info</b> commands. These commands obtain information about the device. For example, your application can determine if a videodisc requires a device element using the following command:<P>
capability videodisc compound file<P>
For most videodisc devices, this example would return <b>false</b>. The flags listed for the required and basic commands provide a minimum amount of information about a device. Many devices supplement the required and basic flags with extended flags to provide additional information about the device. <P>
When you request information with the <b>capability</b>, <b>status</b>, or <b>info</b> command, the argument list can contain only one flag requesting information. The string interface can only return one string or value in response to a <b>capability</b>, <b>status</b>, or <b>info</b> command.<P>
<h3>The Play Command</h3><P>
The <b>play</b> command starts playing a device. Without any flags, the <b>play</b> command starts playing from the current position and plays until the command is halted or until the end of the media or file is reached. For example, "play cdaudio" starts playing an audio disc from the position where it was stopped.<P>
Most devices support the <b>play</b> command also support the <b>from</b> and <b>to</b> flags. These flags indicate the position at which the device should start and stop playing. For example, "play cdaudio from 0" plays the audio disc from the beginning of the first track. The units assigned to the position value depend on the device. For example, the position is normally specified in frames for CAV videodiscs, and milliseconds for digital audio.<P>
As an extended command, devices add flags to use the capabilities of a particular device. For example, the <b>play</b> command for videodisc players adds the flags <b>fast</b>, <b>slow</b>, <b>reverse,</b> and <b>scan</b>. <P>
<h3>Stop, Pause, and Resume Commands </h3><P>
The <b>stop</b> command suspends the playing or recording of a device. Many devices include the basic command <b>pause</b>, which also suspends these sessions. The difference between <b>stop</b> and <b>pause</b> depends on the device. Usually <b>pause</b> suspends operation but leaves the device ready to resume playing or recording immediately. <P>
Using <b>play</b> or <b>record</b> to restart a device will reset the <b>to</b> and <b>from</b> positions specified before the device was paused or stopped. Without the <b>from</b> flag, these commands reset the start position to the current position. Without the <b>to</b> flag, they reset the end position to the end of the media. If you want to continue playing or recording but want to stop at a position previously specified, use the <b>to</b> flag with these commands and repeat the position value. <P>
Some devices include the <b>resume</b> command to restart a paused device. This command does not change the <b>to</b> and <b>from</b> positions specified with the <b>play</b> or <b>record</b> command, which preceded the pause command. <P>
<h2><a name="system"></a>MCI System Commands</h2><P>
The following commands are interpreted directly by MCI. The remaining command tables list commands interpreted by the devices.
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Command</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>sound</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The device name of this command specifies a sound defined in a system setup file.. If it is not found, MCI uses a system default sound. </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>sysinfo</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Obtains MCI system information. One of the following <i>items</i> modifies <b>sysinfo</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>installname</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the name used to install the device.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>quantity</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the number of MCI devices of the type specified by the device-name field. The device-name field must contain a standard MCI device type. Any digits after the name are ignored. The special device name <b>all</b> returns the total number of MCI devices in the system.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>quantity open</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the number of open MCI devices of the type specified by the device name. The device name must be a standard MCI device type. Any digits after the name are ignored. The special device name <b>all</b> returns the total number of MCI devices in the system that are open. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>name</b> <i>index</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the name of an MCI device. The <i>index</i> ranges from 1 to the number of devices of that type. If <b>all</b> is specified for the device name, <i>index</i> ranges from 1 to the total number of devices in the system.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>name</b> <i>index </i><b>open</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the name of an open MCI device. The <i>index</i> ranges from 1 to the number of devices of that type. If <b>all</b> is specified for the device name, <i>index</i> ranges from 1 to the total number of devices in the system.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h2><a name="required"></a>Required Commands for All Devices </h2><P>
The following commands are recognized by all devices. Extended commands can add other options to these commands. A list of the errors common to all the commands follows the required command table.
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Command</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>capability</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Requests information about a particular capability of a device. While other capabilities are defined for specific devices and device types, the following <i>items</i> are always available:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can eject</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the device can eject the media.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can play</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the device can play. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can record</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the device supports recording.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can save</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the device can save data.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>compound device</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the device requires an element name.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>device type</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns one of the following:<BR>
<b>audio tape <BR>
cdaudio<BR>
digital audio tape<BR>
scanner<BR>
sequencer<BR>
videodisc<BR>
videotape<BR>
waveaudio</b><BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>has audio</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the device supports audio playback.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>has video</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the device supports video.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>uses files</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the element of a compound device is a file pathname.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>close</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>When sent to a simple device, closes the device. When sent to a compound device element, closes the element and any resources associated with it. MCI unloads a device when it is no longer being used. </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>info</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Fills a user-supplied buffer with a NULL-terminated string containing textual information. One of the following <i>item</i> modifies <b>info</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>product</b> </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns a description of the hardware associated with a device. This usually includes the manufacturer and model information.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>open</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Initializes the device. The following optional <i>items</i> modify <b>open</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>alias</b> <i>device alias</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies an alternate name for the given device. If specified, it must be used for subsequent references. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>shareable</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Initializes the device or element as shareable. Subsequent attempts to open it fail unless you specify <b>shareable</b> in both the original and subsequent <b>open</b> commands. MCI returns an error if it is already open and not shareable.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>type</b> <i>device type</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the compound device that controls a device element. As an alternative to <b>type</b>, MCI can use the filename extension entries to select the device based on the extension used by the device element. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>status</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Obtains status information for the device. One of the following <i>items</i> modifies <b>status</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>mode</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the current mode of the device. <BR>
Commonly supported standard modes are: <b>not ready</b>, <b>paused</b>, <b>playing</b>, <b>stopped</b>, <b>open</b>, <b>recording</b>, and <b>seeking</b><BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>ready</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the device is ready.<BR>
<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h2><a name="basic"></a>Basic Commands for Specific Device Types</h2><P>
In addition to the commands described previously, each device supports a set of commands specific to its device type. Where possible, these type-specific commands are identical between types. When type-specific commands are common to multiple devices, they are considered basic commands. For example, the basic <b>play</b> command is identical for videodisc and videotape players. Other basic commands are listed in the following table. Although these commands are optional for a device, if a command is used it must recognize all options listed in this table. The options generally provide for a minimum set of capabilities, but some devices may return "unsupported function" if an option is used which clearly doesn't apply.
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Command</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>load</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Load a device element from disk. The following optional <i>item</i> modifies <b>load</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>filename</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the source path and file.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>pause</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Pauses playing or recording.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>play</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Start playing the device. The following optional <i>items</i> modify <b>play</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>from</b> <i>position<BR>
</i><b>to</b> <i>position</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the position to start and stop playing. If <b>from</b> is omitted, the play starts from the current position; if <b>to</b> is omitted, the play stops at the end of the media.<BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>

<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>record</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Start recording data. All data recorded after a file is opened is discarded if the file is closed without saving it. The following optional <i>items</i> modify <b>record</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>insert</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies that new data is added to the device element at the current position.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>from</b> <i>position<BR>
</i><b>to </b><i>position</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the positions to start and stop recording. If <b>from</b> is omitted, the device starts recording at the current position; if <b>to</b> is omitted, the device records until a <b>stop</b> or <b>pause</b> command is received.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>overwrite</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies that new data will replace data in the device element.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The default recording mode (<b>insert</b> or <b>overwrite</b>) depends on the specific device. Each device should define a default recording mode.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>resume</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Resumes playing or recording following a pause.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>save</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Saves the MCI element. The following optional <i>item</i> modifies <b>save</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>filename</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the destination path and file. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>seek</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Moves to the specified position and stops. One of the following is required for <i>item</i> :</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>to</b> <i>position</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the position to stop the seek. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>to start</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Seeks to the start of the media or device element. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>to end</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Seeks to the end of the media or device element. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>set</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the various control <i>items</i>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>audio all off<BR>
audio all on</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Enables or disables audio output<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>audio left off<BR>
audio left on</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Enables or disables output to the left audio channel.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>audio right off<BR>
audio right on</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Enables or disables output to the right audio channel.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>door closed</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Loads the media and closes the door if possible.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>door open</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Opens the door and ejects the tray if possible.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format milliseconds</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets time format to milliseconds. All position information is this format after this command. You can abbreviate milliseconds as <b>ms</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>video off<BR>
video on</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Enables or disables video output.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>status</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Obtains status information for the device. One of the following <i>items</i> modifies <b>status</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>current track</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the current track.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>length</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the total length of the segment.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>length track</b> <i>track_number</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the length of the serial track specified by <i>track_number</i>. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>number of tracks</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the number of tracks on the media. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>position</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the current position.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>position track</b> <i>track_number</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the position of the start of the track specified by <i>track_number</i>. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>start position</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the starting position of the media or device element.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the time format.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>stop</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Stops the device.<BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h2><a name="cdaudio"></a>CD Audio (Redbook) Commands</h2><P>
The CD audio command set provides a common method for playing CD audio sequencesCD audio devices support the following core set of commands:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Command</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>capability</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Requests information about the capabilities of the CD audio device. One of the following <i>items</i> is required:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can eject</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the CD audio device can eject the media.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can play</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the CD audio device can play the media.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can record</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>false</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can save</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>false</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>compound device</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>false</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>device type</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>CDaudio</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>has audio</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b>. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>has video</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>false</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>uses files</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>false</b>..</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>close</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Closes the device.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>info</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Fills a user-supplied buffer with a NULL-terminated string containing textual information. One of the following optional <i>item</i> modifies <b>info</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>product</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the product name and model of the current audio device.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>open</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Initializes the device. MCI reserves cdaudio for the compact disc audio device type. The following optional <i>items</i> modify <b>open</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>alias</b> <i>device_ alias</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies an alternate name for the given device. If specified, it must also be used for subsequent references. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>shareable</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Initializes the device as shareable. Subsequent attempts to open it fail unless you specify <b>shareable</b> in both the original and subsequent <b>open</b> commands. MCI returns an error if it is already open and not shareable.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>pause</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Pauses playing. </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>play</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Starts playing audio. The following optional <i>items</i> modify <b>play</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>from</b> <i>position</i> to <i>position</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the position to start and stop playing.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>resume</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Resumes playing from a paused state.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>seek</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Moves to the specified location on the disc. If already playing or recording, the device is stopped. One of the following <i>items</i> modifies <b>seek</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>to</b> <i>position</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the destination position for the seek. If it is greater than the length of the disc, an out-of-range error is returned.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>to start</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies to seek to the start of the audio data on the CD. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>to end</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies to seek to the end of the audio data on the CD. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>set</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the various control <i>items</i>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>audio all off</b><BR>
<b>audio all on</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Enables or disables audio output..<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>audio left off</b><BR>
<b>audio left on</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Enables or disables output to the left audio channel. <BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>audio right off</b><BR>
<b>audio right on</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Enables or disables output to the right audio channel.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>door closed</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Retracts the tray and closes the door if possible.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>door open</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Opens the door and ejects the tray if possible.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format milliseconds</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the time format to milliseconds. All position information is this format after this command. You can abbreviate milliseconds as <b>ms</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format msf</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the time format to <i>mm</i>:<i>ss</i>:<i>ff</i>, where <i>mm</i> is minutes, <i>ss</i> is seconds, and <i>ff</i> is frames. All position information is in this format after this command. On input, <i>ff</i> can be omitted if 0, and <i>ss</i> can be omitted if both it and <i>ff</i> are 0. These fields have the following maximum values:<BR>
Minutes 99<BR>
Seconds 59<BR>
Frames 74<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format tmsf</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the time format to tt:mm:ss:ff where &quot;tt&quot; is tracks, &quot;mm&quot; is minutes, &quot;ss&quot; is seconds, and &quot;ff&quot; is frames. All position information is in this format after this command. On input &quot;ff&quot; can be omitted if 0, &quot;ss&quot; can be omitted if both it and &quot;ff&quot; are 0, and &quot;mm&quot; can be omitted if it, &quot;ss&quot; and &quot;ff&quot; are 0. These fields have the following maximum values:<BR>
Tracks 99<BR>
Minutes 99<BR>
Seconds 59<BR>
Frames 74<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>status</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Obtains status information for the device. One of the following <i>items</i> modifies <b>status</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>current track</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the current track.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>length</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the total length of the disc. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>length track </b><i>track_number</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the length of the track specified by track_number.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>media present</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the CD is inserted in the drive; otherwise, it returns <b>false</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>mode</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>not ready</b>, <b>open</b>, <b>paused</b>, <b>playing</b>, <b>seeking</b>, or <b>stopped</b> for the current mode of the drive.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>number of tracks</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the number of tracks on the CD.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>position</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the current position. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>position track </b><i>track_no</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the starting position of the track specified by <i>track_no</i>. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>ready</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the drive is ready.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>start position</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the starting position of the CD.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the current time format.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>stop</b> </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Stops playing. <BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h2><a name="midi"></a>MIDI Sequencer Commands</h2><P>
The MIDI sequencer supports the following set of commands:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Command</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>capability</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Requests additional information about the capabilities of the MIDI sequencer. One of the following <i>items</i> is required:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can eject</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>false</b>..</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can play</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the sequencer can play.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can record</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the sequencer can record MIDI data.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can save</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the sequencer can save MIDI data.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>compound device</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Generally returns <b>true</b>; most sequencers are compound devices..</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>device type</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>sequencer</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>has audio</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>has video</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>false</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>uses files</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>close</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Closes the sequencer element and the port and file associated with it.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>info</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Fills a user-supplied buffer with a NULL-terminated string containing textual information. One of the following optional <i>item</i> modifies <b>info</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>product</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the product name of the current MIDI sequencer.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>open</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Initializes the sequencer. The following optional <i>items</i> modify <b>open</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>alias</b> <i>device_ alias</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies an alternate name for the sequencer element. If specified, it must also be used for subsequent references. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>shareable</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Initializes the sequencer element as shareable. Subsequent attempts to open it fail unless you specify shareable in both the original and subsequent <b>open</b> commands. MCI returns an invalid device error if it is already open and not shareable.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>type</b> <i>device_ type</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>MCI reserves sequencer for the MIDI sequencer device type. As an alternative to <b>type</b>, MCI can use the element filename extension entries to select the sequencer. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>pause</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Pauses playing. </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>play</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Starts playing the sequencer. The following optional <i>items</i> modify <b>play</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>from</b> <i>position<BR>
</i><b>to</b><i> position</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the positions to start and stop playing. If <b>from</b> is omitted, play starts at the current position; if <b>to</b> is omitted, play stops at the end of the file. <BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>record</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Starts recording MIDI data. All data recorded after a file is opened is discarded if the file is closed without saving it. The following optional <i>items</i> modify <b>record</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>insert</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies that new data is added to the device element.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>from</b> <i>position<BR>
</i><b>to</b><i> position</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the positions to start and stop recording. If <b>from</b> is omitted, the device starts recording at the current position; if <b>to</b> is omitted, the device records until a <b>stop</b> or <b>pause</b> command is received.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>overwrite</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies that new data will replace data in the device element.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>resume</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Resumes playing or recording following a pause.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>save</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Saves the MCI element. The following item <i>modifies</i> <b>save</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>filename</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The <i>filename</i> specifies the destination path and file. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>seek</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Moves to the specified position in the file. One of the following <i>items</i> is required:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>to</b> <i>position</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the final position for the seek.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>to start</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies to seek to the start of the sequence. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>to end</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies to seek to the end of the sequence. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>set</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the various control <i>items</i>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>audio all off</b><BR>
<b>audio all on</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Enables or disables audio output..<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>audio left off</b><BR>
<b>audio left on</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Enables or disables output to the left audio channel.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>audio right off</b><BR>
<b>audio right on</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Enables or disables output to the right audio channel.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>master MIDI</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the MIDI sequencer as the synchronization source. Synchronization data is sent in MIDI format.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>master none</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Inhibits the sequencer from sending synchronization data.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>master SMPTE</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the MIDI sequencer as the synchronization source. Synchronization data is sent in SMPTE format.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>offset</b> <i>time</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the SMPTE offset <i>time</i> in colon form (<i>hours</i>:<i>minutes</i>:<i>seconds</i>:<i>frames</i>). The offset is the beginning time of a SMPTE based sequence.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>port</b> <i>port_number</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the MIDI port receiving the MIDI messages. This command will fail if the port you are trying to open is being used by another application.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>port mapper</b> </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the MIDI mapper as the port receiving the MIDI messages. This command will fail if the MIDI mapper or a port it needs is being used by another application.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>port none</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Disables the sending of MIDI messages..</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>slave file</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the MIDI sequencer to use file data as the synchronization source. This is the default.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>slave MIDI</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the MIDI sequencer to use incoming data MIDI for the synchronization source. The sequencer recognizes synchronization data with the MIDI format.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>slave none</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the MIDI sequencer to ignore synchronization data.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>slave SMPTE</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the MIDI sequencer to use incoming MIDI data for the synchronization source. The sequencer recognizes synchronization data with the SMPTE format.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>tempo</b> <i>tempo_value</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the tempo of the sequence according to the current time format. For a ppqn-based file, the <i>integer</i> is interpreted as beats per minute. For a SMPTE-based file, the <i>integer</i> is interpreted as frames per second.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format milliseconds</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets time format to milliseconds. All position information is specified as milliseconds following this command. The sequence file sets the default format to ppqn or SMPTE. You can abbreviate milliseconds as <b>ms</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format song pointer</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets time format to song pointer (sixteenth notes). This can only be performed for a sequence of division type ppqn.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format SMPTE 24</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets time format to SMPTE 24 frame rate. All position information is specified in SMPTE format following this command. The sequence file sets the default format to ppqn or SMPTE.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format SMPTE 25</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets time format to SMPTE 25 frame rate. All position information is specified in SMPTE format following this command. The sequence file sets the default format to ppqn or SMPTE.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format SMPTE 30</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets time format to SMPTE 30 frame rate. All position information is specified in SMPTE format following this command. The sequence file sets the default format to ppqn or SMPTE.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format SMPTE 30 drop</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets time format to SMPTE 30 drop frame rate. All position information is specified in SMPTE format following this command. The sequence file sets the default format to ppqn or SMPTE.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>status</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Obtains status information for the MIDI sequencer. One of the following <i>items</i> modifies <b>status</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>current track</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the current track number.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>division type</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns one of the following file division type: PPQN, SMPTE 24 frame, SMPTE 25 frame, SMPTE 30 drop frame, or SMPTE 30 frame. Use this information to determine the format of the MIDI file, and the meaning of tempo and position information.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>length</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the length of a sequence in the current time format. For ppqn files, this will be song pointer units. For SMPTE files, this will be in colon form (<i>hours</i>:<i>minutes</i>:<i>seconds</i>:<i>frames</i>).</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>length track</b> <i>track_number</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the length of a sequence using the current time format. For ppqn files, this will be song pointer units. For SMPTE files, this will be in colon form (<i>hours</i>:<i>minutes</i>:<i>seconds</i>:<i>frames</i>).</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>master</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>midi</b>, <b>none</b>, or <b>smpte</b> depending on the type of synchronization set.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>media present</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>The sequencer returns <b>true</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>mode</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>not ready</b>, <b>paused</b>, <b>playing</b>, <b>seeking</b>, or <b>stopped</b>. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>number of tracks</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the number of tracks.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>offset</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the offset of a SMPTE-based file. The time is returned in colon form (<i>hours</i>:<i>minutes</i>:<i>seconds</i>:<i>frames</i>). The offset is the starting time of a SMPTE based sequence.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>port</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the MIDI port number assigned to the sequence. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>position</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the current position of a sequence in the current time format. For ppqn files, this will be song pointer units. For SMPTE files, this will be in colon form (<i>hours</i>:<i>minutes</i>:<i>seconds</i>:<i>frames</i>).</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>position track</b> <i>track_number</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the current position of the track specified by <i>track_number</i> in the current time format. For ppqn files, this will be song pointer units. For SMPTE files, this will be in colon form (<i>hours</i>:<i>minutes</i>:<i>seconds</i>:<i>frames</i>). </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>ready</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the device is ready.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>slave</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>file</b>, <b>midi</b>, <b>none</b>, or <b>smpte</b> depending on the type of synchronization set.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>start position</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the starting position of the media or device element.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>tempo</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the current tempo of a sequence in the current time format. For files with ppqn format, the tempo is in beats per minute. For files with SMPTE format, the tempo is in frames per second.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the time format.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>stop</b> </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Stops playing. <BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h2><a name="videodisc"></a>Videodisc Player Commands  </h2><P>
Videodisc players support the following core set of commands:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Command</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>capability</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Reports the capabilities of the device. The device should report capabilities according to the type of disc (CAV or CLV) inserted in the drive. If no disc is inserted, the device should assume CAV. One of the following optional <i>items</i> modifies <b>capability</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can eject</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the device can eject the media.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can play</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the device supports playing. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can record</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the video device can record. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can reverse</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the device can play in reverse, <b>false</b> otherwise. This is always <b>false</b> if a CLV disc is inserted.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can save</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>false</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>compound device</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>false</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>device type</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>videodisc</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>fast play rate</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the standard fast play rate of the player in frames per second. Returns 0 if the device cannot play fast.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>has audio</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the videodisc player has audio.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>has video</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>media type</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <B>CAV</B>, <B>CLV</B>, or <b>other</b>, depending on the type of videodisc.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>normal play rate</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the normal play rate in frames per second. Returns 0 for CLV discs.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>slow play rate</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the standard slow play rate in frames per second. Returns 0 if the device cannot play slow.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>uses files</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>false</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>close</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Closes the device.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>escape</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sends custom information to a device. The following <i>item</i> modifies <b>escape</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>string</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the custom infomation sent to the device.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>info</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Fills a user-supplied buffer with a NULL-terminated string containing textual information. The following optional <i>item</i> modifies <b>info</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>product</b> </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the product name of the device that the peripheral is controlling.<b>.</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>open</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Initializes the device. MCI reserves video disc for the videodisc device type. The following optional <i>items</i> modify <b>open</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>alias</b> <i>device_ alias</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies an alternate name for the given device. If specified, it must also be used for subsequent references. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>shareable</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Initializes the device as shareable. Subsequent attempts to open it fail unless you specify <b>shareable</b> in both the original and subsequent <b>open</b> commands. MCI returns an invalid device error if it is already open and not shareable.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>pause</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Stops playing. If a CAV disc is playing, it also freezes the video frame. If a CLV disc is playing, the player is stopped.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>play</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Starts playing. The following optional <i>items</i> modify <b>play:</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>fast<BR>
slow</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Indicates that the device should play faster or slower than normal. To determine the exact speed on a particular player, use the <b>status speed</b> command. To specify the speed more precisely, use the <b>fps</b> flag. <b>Slow</b> applies only to CAV discs.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>from</b> <i>position<BR>
</i><b>to</b> <i>position</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the positions to start and stop playing. Positions are in frames for CAV discs and in seconds for CLV discs, unless <b>chapter</b> is also used (in which case, the position is given in chapters). If <b>from</b> is omitted, play starts at the current position; if <b>to</b> is omitted, the play stops at the end of the disc.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>reverse</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the play direction to backwards. This applies only to CAV discs.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>scan</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Indicates the play speed is as fast as possible, possibly with audio disabled. This applies only to CAV discs.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>speed</b> <i>integer</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the rate of play. Currently supported speed values are measured in frames per second, which is the default. This applies only to CAV discs.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>resume</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Resumes playing.</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>seek</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Searches using fast forward or fast reverse with video and audio off. The following optional <i>items</i> modify <b>seek</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>reverse</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Indicates the seek direction on CAV discs is backwards. This modifier is invalid if <b>to</b> is specified.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>to</b> <i>position</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the end position to stop the seek. If <b>to</b> is not specified, the seek continues until the end of the media is reached.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>to start</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies to seek to the start of the disc. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>to end</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies to seek to the end of the disc. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>set</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the various control <i>items</i>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>audio all off</b><BR>
<b>audio all on</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Enables or disables audio output.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>audio left off</b><BR>
<b>audio left on</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Enables or disables output to the left audio channel.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>audio right off</b><BR>
<b>audio right on</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Enables or disables output to the right audio channel.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>door open</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Opens the door and ejects the tray, if possible.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>door closed</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Retracts the tray and closes the door, if possible.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format frames</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the position format to frames on CAV discs. All position information is specified in this format following this command. This is the default for CAV discs.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format hms</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets position format to <i>h</i>:<i>mm</i>:<i>ss</i> where <i>h</i> is hours, <i>mm</i> is minutes, and <i>ss</i> is seconds. All position information is specified in this format following this command. On input, <i>h</i> may be omitted if 0, and <i>mm</i> may be omitted if both it and <i>h</i> are 0. This is the default for CLV discs.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format milliseconds</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the position format to milliseconds. All position information is specified in this format following this command. You can abbreviate milliseconds as <b>ms</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format track</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the position format to tracks (chapters). All position information is specified in this format following this command. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>video on<BR>
video off</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Turns the video on or off.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>spin</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Starts the disc spinning or stops the disc from spinning. One of the following <i>items</i> modifies <b>status</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>down</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Stops the disc from spinning.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>up</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Starts the disc spinning.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>status</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Obtains status information for the device. One of the following <i>items</i> modifies <b>status</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>current track</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the current track (chapter) number.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>disc size</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns either 8 or 12 to indicate the size of the loaded disc in inches.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>forward</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the play direction is forward or if the device is not playing; <b>false</b> if the play direction is backward.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>length</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the total length of the segment.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>length track</b> <i>track_number</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the length of the track (chapter) specified by <i>track_number</i>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>media present</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if a disc is inserted in the device, <b>false</b> otherwise.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>media type</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns either <B>CAV</B>, <B>CLV</B>, or <b>other</b> depending on the type of videodisc.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>mode</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>not ready</b>, <b>opened</b>, <b>paused</b>, <b>parked</b>, <b>playing</b>, <b>scanning</b>, <b>seeking</b>, or <b>stopped</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>number of tracks</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the number of tracks (chapters) on the media. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>position</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the current position.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>position track</b> <i>track_number</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the position of the start of the track (chapter) specified by <i>track_number</i>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>ready</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the device is ready.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>side</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns 1 or 2 to indicate which side of the disc is loaded.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>speed</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the speed in frames per second.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>start position</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the starting position of the disc.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the time format.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>step</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Step the play one or more frames forward or backward. The default action is to step one frame forward. The <b>step</b> command applies only to CAV discs. The following <i>items</i> modifies <b>step</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>by</b> <i>frames</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the number of <i>frames</i> to step. If a negative value is used, the <b>reverse</b> flag is ignored.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>reverse</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Step backward.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>stop</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Stop playing. <BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>
<h2><a name="audio"></a>Waveform Audio Commands</h2><P>
Waveform audio drivers must support the following core set of commands:
<BR>
<P>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="Arial" SIZE=2><b>Command</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>Description</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>capability</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Requests additional information about the capabilities of the waveform audio driver. One of the following <i>items</i> modify <b>capability</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can eject</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>false</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can play</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the device can play. The wave audio device returns true if an output device is available.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can record</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the waveform driver can record. The waveform audio device returns <b>true</b> if an input device is available.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>can save</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the wave audio device can save data. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>compound device</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Generally returns <b>true</b>; most waveform audio devices are compound devices.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>device type</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>waveaudio</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>has audio</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b></FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>has video</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>false</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>inputs</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the total number of input devices.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>outputs</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the total number of output devices.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>uses files</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>close</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Closes the device element and any resources associated with it. </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>cue</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Prepares for playing or recording. The <b>cue</b> command does not have to be issued prior to playing or recording. However, depending on the device, it might reduce the delay associated with the <b>play</b> or <b>record</b> command. This command fails if playing or recording is in progress. The <i>item</i> is one of the following:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>input</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Prepares for recording.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>output</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Prepares for playing. This is the default.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>delete</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Deletes a data segment from the MCI element. The following optional <i>items</i> modify <b>delete</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>from</b> <i>position<BR>
</i><b>to</b> <i>position</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the positions to start and stop deleting data. If <b>from</b> is omitted, the deletion starts at the current position; if <b>to</b> is omitted, the deletion stops at the end of the file or waveform.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>info</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Fills a user-supplied buffer with a NULL-terminated string containing textual information. One of the following <i>items</i> modifies <b>info</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>file</b> </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the current filename.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>product</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the product name of the current audio output device.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>input</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the product name of the current waveform input device or <b>none</b> if no device is set.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>output</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the product name of the current waveform output device or <b>none</b> if no device is set.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>open</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Initializes the device. The following <i>items</i> are optional:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>alias</b> <i>device_ alias</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies an alternate name for the given device. If specified, it must also be used the alias for references. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>buffer</b> <i>buffer_size</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the size in seconds of the buffer used by the wave audio device. The default size of the buffer is set when the wave audio device is installed or configured. Typically, the buffer size is set to 4 seconds.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>shareable</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Initializes the device element as shareable. Subsequent attempts to open it fail unless you specify <b>shareable</b> in both the original and subsequent <b>open</b> commands. MCI returns an error if it is already open and not shareable. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>type</b> <i>device_type</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the compound device used to control a device element. MCI reserves waveaudio for the waveform audio device type. As an alternative to <b>type</b>, MCI can use the element filename extension entries to select the controlling device </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>pause</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Pauses playing or recording. </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>play</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Starts playing audio. The following optional <i>items</i> modify <b>play</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>from</b> <i>position</i><BR>
<b>to</b> <i>position</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the positions to start and stop playing. If <b>from</b> is omitted, play starts at the current position; if <b>to</b> is omitted, play stops at the end of the file or waveform.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>record</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Starts recording audio. All data recorded after a file is opened is discarded if the file is closed without saving it. The following optional <i>items</i> modify <b>record</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>insert</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies that new data is added to the device element.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>from</b> <i>position<BR>
</i><b>to</b> <i>position</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the positions to start and stop recording. If <b>from</b> is omitted, the device starts recording at the current position; if <b>to</b> is omitted, the device records until a <b>stop</b> or <b>pause</b> command is received.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>overwrite</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies that new data will replace data in the device element. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>resume</b> </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Resumes playing or recording following a pause. </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>save</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Saves the MCI element in its current format. The following item modifies <b>save</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><i>filename</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the file and pathname used to save data.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>seek</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Moves to the specified location in the file. Playback or recording is stopped after the seek. One of the following items modify <b>seek</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>to</b> <i>position</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies the stop position.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>to start</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies to seek to the first sample. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>to end</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Specifies to seek to the last sample. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>set</b> <i>items</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the following control <i>items</i>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>alignment</b> <i>integer</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the alignment of data blocks. The file is saved in the new format. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>any input</b> </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Use any input that supports the current format when recording. This is the default.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>any output</b> </FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Use any output that supports the current format when playing. This is the default.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>audio all off</b><BR>
<b>audio all on</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Enables or disables audio output.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>audio left off</b><BR>
<b>audio left on</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Enables or disables output to the left audio channel. <BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>audio right off</b><BR>
<b>audio right on</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Enables or disables output to the right audio channel.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>bitspersample</b> <i>bit_count</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the number of bits per sample played or recorded. The file is saved in this format.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>bytespersec</b> <i>byte_rate</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the average number of bytes per second played or recorded. The file is saved in this format.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>channels</b> <i>channel_count</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the channel count for playing and recording. The file is saved in this format.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>format tag</b> <i>tag</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the format type for playing and recording. The file is saved in this format.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>format tag pcm</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the format type to PCM for playing and recording. The file is saved in this format.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>input</b> <i>integer</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the audio channel used as the input.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>output</b> <i>integer</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the audio channel used as the output.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>samplespersec</b> <i>integer</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the sample rate for playing and recording. The file is saved in this format.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format bytes</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the time format to bytes. All position information is specified as bytes following this command.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format milliseconds</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the time format to milliseconds. All position information is specified as milliseconds following this command. You can abbreviate milliseconds as <b>ms</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format samples</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Sets the time format to samples. All position information is specified as samples following this command.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>status</b> <i>item</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Obtains status information for the device. One of the following <i>items</i> modifies <b>status</b>:</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>alignment</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the block alignment of data in bytes.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>bitspersample</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the bits per sample.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>bytespersec</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the average number of bytes per second played or recorded.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>channels</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the number of channels set (1 for mono, 2 for stereo).</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>current track</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the index of the current track.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>format tag</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the format tag.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>input</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the currently set input. If no input is set, the error returned indicates that any device can be used.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>length</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the total length of the waveform. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>length track</b> <i>track_number</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the length of the waveform track.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>level</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the current audio sample value.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>media present</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>mode</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>not ready, paused</b>, <b>playing</b>, <b>stopped</b>, <b>recording</b>, or <b>seeking</b>.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>number of tracks</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the number of tracks (chapters).</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>output</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the currently set output. If no output is set, the error returned indicates that any device can be used.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>position</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the current position. </FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>position track</b> <BR>
<i>track_number</i></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the position of the track specified by <i>track_number</i>.<BR>
<P>
</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>ready</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns <b>true</b> if the device is ready.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>samplespersec</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the number of samples per second played or recorded.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>start position</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the starting position of the waveform data.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2>&nbsp;</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><b>time format</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Returns the current time format.</FONT></TD>
</TR><P>
<TR VALIGN=TOP>
<TD><FONT FACE="Arial" SIZE=2><b>stop</b></FONT></TD>
<TD><FONT FACE="Arial" SIZE=2>Stops playing or recording.<BR>
</FONT></TD>
<TD><FONT FACE="Arial" SIZE=2><BR>
<P>
</FONT></TD>
</TR>
</TABLE>
<P>

</BODY></HTML>

------------cpWK6SNTBdR6XrFMatzjTO--
