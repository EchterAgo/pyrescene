\documentclass[12pt]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{amsmath}
\lstloadlanguages{C}
\usepackage{ifthen}
\usepackage{color}
\usepackage{pgf}
\usepackage{longtable}
\usepackage[pdfborder=0]{hyperref}
\usepackage{fancyhdr}
\setlength{\parindent}{0pt}
\setlength{\textwidth}{15cm}
\setlength{\hoffset}{-0.5cm}
\setlength{\voffset}{-2cm}
\addtolength{\textheight}{2cm}
\pagestyle{fancy}
\lhead{}
\rhead{}
\chead{\Matroska file format}
\begin{document}
\newcommand{\f}{\textbf}
\newcommand{\el}[1]{\textsc{\textbf{#1}}}
\newcommand{\Matroska}{\textsc{Matroska }}
\newcommand{\bold}[1]{\textbf{#1}}
\newcommand{\picnormal}[1]{{\includegraphics[width=15.0cm]{#1}}\\[0.2cm]}

% comment this line to render without pictures
%\renewcommand{\picnormal}[1]{}

\newcommand{\pic}[1]{\picnormal{#1}}

\setlength{\parskip}{1mm}
\setlength{\parindent}{0cm}
\renewcommand{\familydefault}{bch}
\renewcommand{\seriesdefault}{m}
\renewcommand{\baselinestretch}{1.1}
\normalfont

% display default value only if it's not '-'
\newcommand{\defval}[1]{\ifthenelse{\not\equal{#1}{-}}{\\\small def: #1}{}}

% #1 -> type
% #2 -> element name
% #3 -> EBML ID
% #4 -> occurence restriction
% #5 -> default value
% #6 -> description
\newcommand{\element}[6]{
\parbox[t]{4cm}{{\bfseries \small #1, \# #4} \\ {\small \el{#2}} \\ {\small ID:\texttt{ #3}} {\defval{#5}}\vspace*{2mm}} & {\small #6} \\\hline}

\newcommand{\enumeratedelement}[6]{
\parbox[t]{4cm}{{\bfseries \small #1, \# #4} \\ {\small \el{#2} ($\rightarrow$\ref{enum_#2})} \\ {\small ID:\texttt{ #3}}  {\defval{#5}}\vspace*{2mm}} & {\small #6} \\\hline
}

% #1 -> type
% #2 -> element name to display
% #3 -> element name
% #4 -> EBML ID
% #5 -> occurence restriction
% #6 -> default value
% #7 -> description
\newcommand{\enumeratedlongelement}[7]{
\parbox[t]{4cm}{{\bfseries \small #1, \# #5} \\ {\small \el{#2} ($\rightarrow$\ref{enum_#3})} \\ {\small ID:\texttt{ #4}}  {\defval{#6}}\vspace*{2mm}} & {\small #7} \\\hline
}

% #1 -> element name
% #2 -> EBML ID
% #3 -> occurence restriction
% #4 -> description
\newcommand{\masterelement}[4]{\parbox[t]{4cm}{{\bfseries \small Master, \# #3} \\ {\small \el{#1} ($\rightarrow$\ref{tab_#1})} \\ {\small ID:\texttt{ #2}} \\[-0.3cm]} & {\small #4} \\\hline  }

\newcommand{\childof}[1]{child of \el{#1}~($\rightarrow$\ref{tab_#1})}
\newcommand{\refsec}[1]{($\rightarrow$~section~\ref{#1})}
\newcommand{\refpage}[1]{($\rightarrow$~page~\pageref{#1})}
\newcommand{\reftab}[1]{($\rightarrow$~Table~\ref{#1})}

\newcommand{\occnomatter}{$\geq 0$ }
\newcommand{\occonce}{$=1$ }
\newcommand{\occveryonce}{$=1$ (!)}
\newcommand{\occunique}{$\leq 1$ }
\newcommand{\occmandatory}{$\geq 1$ }
\newcommand{\occverymandatory}{$\geq 1$ (!)}
\newcommand{\valueof}[1]{\el{\$#1}}

% remove captions
\makeatletter
\def\LT@makecaption#1#2#3{%
  \LT@mcol\LT@cols c{\hbox to\z@{\hss\parbox[t]\LTcapwidth{%
    \sbox\@tempboxa{#1{#2: }#3}%
  \ifdim\wd\@tempboxa>\hsize
      %#1{#2: }#3 %
  \else
      %\hbox to\hsize{\hfil\box\@tempboxa\hfil}%
  \fi
\endgraf%\vskip%\baselineskip
}%
  \hss}}}
\makeatother

\newenvironment{elementdescription}[2]
{
\begin{longtable}{|p{4cm}|p{10cm}|}
\caption[#2]{#2}%\multicolumn{2}{c}{}
\label{tab_#2}
  \\\hline \multicolumn{2}{|c|}{\parbox{14cm}{\centering \bfseries Table \ref{tab_#2}: #1}}
  \\\hline \multicolumn{1}{|c}{Element} & \multicolumn{1}{|c|}{Description}
  \\\hline
\endfirsthead
  \hline \multicolumn{1}{|c}{Element} & \multicolumn{1}{|c|}{Description}
  \\\hline
\endhead
  \hline \multicolumn{2}{r}{\small \emph{\small \el{#2} continued on next page}}\\
\endfoot
  \hline \multicolumn{1}{l}{Index $\rightarrow$page \pageref{listoftables}} & \multicolumn{1}{r}{\small \emph{\small end of \el{#2}}}\\
\endlastfoot
}{
\hline\end{longtable}
}

\newenvironment{enumtable}[2]
{
\begin{longtable}{|p{4cm}|p{10cm}|}
\multicolumn{2}{c}{}
\label{enum_#2}
  \\\hline \multicolumn{2}{|c|}{\parbox{14cm}{\centering \bfseries Table \ref{enum_#2}: #1}}
  \\\hline \multicolumn{1}{|c}{Value} & \multicolumn{1}{|c|}{Description}
  \\\hline
\endfirsthead
  \hline \multicolumn{1}{|c}{Value} & \multicolumn{1}{|c|}{Description}
  \\\hline
\endhead
  \hline \multicolumn{2}{r}{\small \emph{\small \el{#2} continued on next page}}\\
\endfoot
  \hline \multicolumn{2}{r}{\small \emph{\small end of \el{#2}}}\\
\endlastfoot
}{
\hline\end{longtable}
}
\newcommand{\enumitem}[2]{\parbox{4cm}{\vspace*{2mm}#1\vspace*{2mm}} & \parbox{10cm}{\vspace*{2mm}#2\vspace*{2mm}}\\}


\begin {center}
\Huge
\f{Matroska File Format \\ (under construction!)}

\end {center}
\begin{center}
Alexander No√©

alex@alexander-noe.com

Last change: \today
\end{center}

\setcounter{tocdepth}{2}
\tableofcontents
\label{listoftables}
\listoftables
\newpage
\Large
\setlength{\parskip}{2mm}
\section{Introduction}
\normalsize
This document is intended to be used by developers who want to implement support for the \Matroska file format in their applications, but who want to build this support from scratch rather than using existing implementations, or people who just want to understand the \Matroska file format in detail. Thus, the file format itself is described, the usage of existing libraries isn't.

This document does not replace the official documentation\footnote{\url{http://www.matroska.org/technical/specs/index.html}}. It is less condensed, but not necessarily complete. Especially, in the case that \Matroska supports Digital Restrictions Management one day, I will expressively not document that part. Also, typos in element IDs are never impossible.

When speaking about element occurence, elements can be mandatory or not, elements may be present several times inside a parent element or not etc. Occurence restrictions will be indicated using expressions like \occonce or \occmandatory etc. Those restrictions will exclude cases which do not technically render a file unusable or ambigous, but which are unreasonable, like a file with no \el{SegmentUID}, see section \ref{sec_SegmentInfo}. The same way it would be weird (but not make a file unusable) to have a \el{Chapters} element (which is supposed to describes chapters) which is empty. An element that must occur at least once is a reasonable file is called ``mandatory''. When an element is really mandatory, i.e the file or a part of it is useless when it's missing, it will be labeled as \occverymandatory\ or \occveryonce. An example would be the codec ID of a track, without which a track cannot be decoded at all.

The official Matroska specification pages use the following interpretation of ``mandatory'' and ``default'': When an element has a default value that is used if the element itself is not present, the value cannot be missing, thus the element is inherently mandatory. This interpretation of ``mandatory'' being weird, this document considers an element mandatory when it must be physically present in the file. Also, default values can only be valid values. Consequently, a mandatory element cannot have a default value because if it had one, it couldn't be mandatory anymore.

In this document, element names are always printed like \el{This}, element values are printed like \valueof{This}, as in ``if \valueof{ThisFlag}=1, ...''. 

If you have any questions concerning this document, if you have comments, additions, if you have found an error, or if you want to contact me for whatever reason, please send me an e-mail (include 'matroska' in the topic!). You can contact me in german, english or french, whatever you prefer. Just don't ask me if you can ask something or if I could document some Digital Restrictions Management.

This document is powered by LaTeX, so changing the order of certain tables or the style of those tables etc. is, with certain limits, possible within a few seconds.

Screenshots of real life file structures are used to illustrate the file structure. All of them have been made using the EBML Tree Viewer in AVI-Mux GUI.
\newpage
\section{EBML - basics}
\normalsize
EBML files use integers of variable size. This way, the file format doesn't waste space with storing 32 or even 64 bit integers in placed where they \emph{might sometimes} occur. The way the size is coded is inspired by the UTF-8 encoding format.
\subsection{Unsigned Integer Values of Variable Length (''vint``)}
The length of an integer is equivalent to $length~=~1~+~[number\_of\_leading\_zero\_bits]$. All integers use big endian. You could use more than 7 leading zeros, then the first byte would be 0x00, however, this would only be needed if integers longer than 56 bits are required. This is forbidden in \Matroska files.

\f{Example:}
3A 41 FE: 

The first byte 3A ({\color{red}00}11 1010) has 2 leading zeros, resulting in a total length of 3 bytes. The first `1' in the byte (00{\color{red}1}1 1010) is just needed to finish the sequence of leading zeros and can't be used to store the value either. Thus, it is reset to obtain the value this byte sequence represents. The result is then \textsc{0x1A41FE}. As you can see, you lose one bit per byte to know how long a number is, and you can use 7 bits per byte to store the integer's value itself.

Of course, the value 0x1A41FE could also be written as 10 1A 41 FE  or  08 00 1A 41 FE (do the decoding on a piece of paper if it's not clear), however, when writing EBML files, the shortest possible encoding should be used to avoid wasting space, which is the very point of this coding scheme.

\f{Unknown Length}

All bits after the leading zeros being set to one, such as FF or 7F FF, indicates an \textsl{unknown length}. Muxers shall avoid writing unknown length values whenever possible. The only exception is the last Level 0 element of a file. If encoding a number as described above results in such a sequence, it must be encoded again with a greater destination length. Example: When encoding 16383 as described above, the result is 7F FF. In 7F FF, all bits after the leading zero are set, which would indicate an unknown length. That means, the length is increased to 3, and the number is encoded again to 20 3F FF.

\f{Note}

It is possible to use a lookup table to determine the total length from the first byte. The Matroska file format does not allow integer lengths greater than 8, meaning that the number of leading zeros is not higher than 7 and that the total length can always be retrieved from the first byte.

\subsection{EBML elements}
One piece of information is stored the following way:

\begin{verbatim}    typedef struct {
        vint      ID        // EBML-ID
        vint      size      // size of element
        char[size] data     // data
    } EBML_ELEMENT;\end{verbatim}

The length of ID shall be called \texttt{s\_ID}, the length of size shall be called \texttt{s\_size}.
Elements that contain other EBML Elements are called \textsl{EBML Master elements}.\\[0.2cm]
Generally, the order of EBML elements inside a parent element is not fixed. In some cases,
a certain order is recommended, but it is never mandatory. Especially, no element order should be 
assumed inside small parent elements.

\subsection{Signed Integer Values of Variable Length (svint)}
Signed integers have the following value:
Read the integer as Unsigned Integer and then subtract \begin{verbatim}    vsint_subtr[length-1]\end{verbatim}

where
\begin{verbatim}
    __int64 vsint_subtr [] = 
        { 0x3F, 0x1FFF, 0x0FFFFF, 0x07FFFFFF, 
          0x03FFFFFFFF, 0x01FFFFFFFFFF, 
          0x00FFFFFFFFFFFF, 0x007FFFFFFFFFFFFF };
\end{verbatim}

\subsection{Data Types}

Whereas \texttt{vint}s are used in the header section of EBML elements, the data types describes in this section occur in the data section.

\subsubsection{Signed and Unsigned Integers (int and uint)}

Integers, signed as well as unsigned, are stored in big endian byte order, with leading 0x00 (in case of positive values) and 0xFF (in case of negative values) being cut off (example for int: -257 is 0xFE 0xFF). An int/uint may not be larger than 8 bytes.

\subsubsection{Float}
A \texttt{Float} value is a 32 or 64 bit real number, as defined in IEEE. 80 Bit values have been in the specification, but have been removed and should not be used. The bytes are stored in big endian order. 

\subsubsection{Types of Strings}
\f{String} refers to an ASCII string.\\
\f{UTF-8} refers to a string that is encoded as UTF-8

\newpage

\section{\Matroska files - Top-Level elements}

\Matroska files only have two different top level elements:

\pic{matroska_l0.png}

\subsection{EBML}
This header describes the contents of an EBML file. There should be only one EBML
header in one file. Any further EBML headers do not render a file invalid,
but shall be ignored by any application reading the file. Files with more than one EBML header could be created for instance if two or more files are appended by using the \texttt{copy /b} command.
\subsection{Segment}
A \el{Segment} contains multimedia data, as well as any header data necessary for
replay. There can be several \el{Segment}s in one \Matroska file, but this is not
encouraged to be done, as not many tools are able to handle multisegment \Matroska files correctly.
If you want to replay multisegment \Matroska files on Windows, please use Haali Media splitter\footnote{\url{http://haali.cs.msu.ru/mkv/}} 
\newpage
\section{\el{EBML} - The EBML file header}
The \el{EBML} top level element contains a description of the file type, such as EBML version, file type name, file type version etc. 

\pic{ebml.png}

Obviously, this header being missing makes it necessary to guess the file type.
\begin{elementdescription}{The \el{EBML} element (Top-Level)}{EBML}
\element{uint}{EBMLVersion}{42 86}{\occunique}{1}{indicates the version of the EBML Writer that has been used to create a file}
\element{uint}{EBMLReadVersion}{42 F7}{\occunique}{1}{indicates the minimum version an EBML parser needs to be compliant with to be able to read the file}
\element{uint}{EBMLMaxIDLength}{42 F2}{\occunique}{4}{indicates the length of the longest EBML-ID the file contains. In case of matroska, this value is 4. Any EBML-ID which is longer than the value of this element shall be considered invalid.}
\element{uint}{EBMLMaxSizeLength}{42 F3}{\occunique}{8}{indicates the maximum \texttt{s\_size} value the file contains. Any EBML element having an \texttt{s\_size} value greater than EBMLMaxSizeLength shouldl be considered invalid.}
\element{string}{DocType}{42 82}{\occunique}{matroska}{describes the contents of the file. In the case of a \Matroska file, its value is \texttt{'matroska'}}
\element{uint}{DocTypeVersion}{42 87}{\occunique}{1}{indicates the version of the \valueof{DocType} writer used to create the file}
\element{uint}{DocTypeReadVersion}{42 85}{\occunique}{1}{indicates the minimum version number a \valueof{DocType} parser must be compliant with to read the file.}
\end{elementdescription}

As you can see, in the case of Matroska files all child elements of the \el{EBML} element have a default value. Thus, an empty \el{EBML} element would technically introduce a Matroska file (with file type version 1, maximum ID length 4, maximum size length 8 etc.) correctly. However, I don't recommend to push the specifications like this.

It is not recommended to use either IDs or size values greater than 8 bytes. While it's clear that 8 bytes are enough to represent any size of anything on any hard disc, one might think about using IDs larger than 8 bytes. However, since the ID is considered an integer, treating IDs larger than 8 bytes is difficult on current CPUs, which are limited to 64 bit for simple integer operations.

\newpage
\section{Level 1 - Elements inside Segments}
\subsection{Overview}

\pic{matroska_segment.png}

\begin{elementdescription}{The \el{Segment} element (Top-Level)}{Segment}
\masterelement{SegmentInfo}{15 49 A9 66}{\occonce}{\el{SegmentInfo} contains general information about a segment, like an UID, a title etc. This information is not really required for playback, but should be there \refsec{sec_SegmentInfo}.}
\masterelement{SeekHead}{11 4D 9B 74}{\occnomatter}{A \el{SeekHead} is an index of elements that are children of \el{Segment}. It can point to other \el{SeekHead}s, but not to itself. If all non-\el{Cluster} precede all \el{Cluster}s \refsec{sec_Cluster}, a \el{SeekHead} is not really necessary, otherwise, a missing \el{SeekHead} leads to long file loading times or the inability to access certain data.}
\masterelement{Cluster}{1F 43 B6 75}{\occnomatter}{A \el{Cluster} contains video, audio and subtitle data. Note that a \Matroska file could contain chapter data or attachments, but no multimedia data, so \el{Cluster} is not a mandatory element.}
\masterelement{Tracks}{16 54 AE 6B}{\occnomatter}{A \el{Tracks} element contains the description of some or all tracks (preferably all). This element can be repeated once in a while for backup purposes. A file containing only chapters and attachments does not have a \el{Tracks} element, thus it's not mandatory.}
\masterelement{Cues}{1C 53 BB 6B}{\occunique}{The \el{Cues} element contains a timestamp-wise index to \el{Cluster}s, thus it's helpful for easy and quick seeking.}
\masterelement{Attachments}{19 41 A4 69}{\occunique}{The \el{Attachments} element contains all files attached to this \el{Segment}.}
\masterelement{Chapters}{10 43 A7 70}{\occonce}{The \el{Chapters} elements contains the definition of all chapters and editions of this \el{Segment}}
\masterelement{Tags}{12 54 C3 67}{\occunique}{The \el{Tags} element contains further information about the \el{Segment} or elements inside the \el{Segment} that is not really required for playback.}
\end{elementdescription}

\subsection{SegmentInfo}
\label{sec_SegmentInfo}
The \el{SegmentInfo} element contains general information about the \el{Segment}, such as its
duration, the application used for writing the file, date of creation, a unique 128
bit ID, to name a few only. Information included in the \el{SegmentInfo} element is not
required for playback, but should be written by any \Matroska muxer.\\[0.2cm]
\begin{center}
\pic{SegmentInfo}
\tiny
(read: <element name> (<s\_size + s\_ID>: <size> bytes at <position in file>: value)
\end{center}
\normalsize
\begin{elementdescription}{The \el{SegmentInfo} element, \childof{Segment}}{SegmentInfo}
\element{char[16]}{SegmentUID}{73 A4}{\occonce}{-}{a unique 128 bit number identifying a \el{Segment}. Obviously, a file can only be referred to by another file if a \el{SegmentUID} is present, however, playback is possible without that UID.}
\element{utf-8}{SegmentFilename}{73 84}{\occunique}{-}{contains the name of the file the \el{Segment} is stored in. Since renaming files is easy, the reliability of this element's value should not be overrated.}
\element{char[16]}{PrevUID}{3C B9 23}{\occunique}{-}{contains the unique 128 bit ID of the \el{Segment } that is replayed before the currently active \el{Segment}, i.e. the ID of the \el{Segment} that should be loaded if the user tries to seek to a timecode earlier than the earliest timecode of the active \el{Segment}. That \el{segment} should, of course, be easy to locate, for instance in a file in the same directory.}
\element{utf-8}{PrevFilename}{3C 83 AB}{\occunique}{-}{contains the name of the file in which the \el{Segment } having the ID \valueof{PrevUID} is stored. \el{PrevFilename} should not be considered reliable for the same reason as \el{SegmentFilename}, however, it could be the first filename the player is looking for when the \el{segment} described in \el{PrevUID} is needed}
\element{char[16]}{NextUID}{3E B9 23}{\occunique}{-}{contains the unique 128 bit ID of the \el{Segment} that is replayed after the currently active \el{Segment}, i.e. the ID of the \el{Segment} that should be loaded if the user tries to seek to a timecode after the end of the active \el{Segment}. Like \el{PrevUID}, the corresponding \el{Segment} should be easy to locate.}
\element{utf-8}{NextFilename}{3E 83 BB}{\occunique}{-}{contains the name of the file in which the \el{Segment} having the ID \valueof{NextUID} is stored. \el{NextFilename} shall not be considered reliable for the same reason as \el{SegmentFilename}.}
\element{uint}{TimecodeScale}{2A D7 B1}{\occunique}{-}{Each scaled timecode in a \Matroska file is multiplied by \el{TimecodeScale} to obtain a timecode in nanoseconds. Note that not all timecodes are scaled!}
\element{float}{Duration}{44 89}{\occunique}{-}{The \el{Duration} indicates the duration of the \el{Segment}. The duration measured in nanoseconds is scaled and is thus equal to \valueof{Duration} * \valueof{TimecodeScale}. This element should be written.}
\element{utf-8}{Title}{7B A9}{\occunique}{-}{Contains a general name of the \el{Segment}, like \texttt{''Lord of the Rings - The Two Towers``}. No language can be attached to the title, however, Tags \refsec{sec_Tags} could be used to define several titles for a segment. This is not yet commonly done, though.}
\element{string}{MuxingApp}{4D 80}{\occonce}{-}{contains the name of the library that has been used to create the file (like ''libmatroska 0.7.0``). This element should be written by any muxer! Especially if non-compliant files are encountered, this help to know who must be blamed for that file.}
\element{utf-8}{WritingApp}{57 41}{\occonce}{-}{contains the name of the application used to create the file (like ''mkvmerge 0.8.1``). This element should be written for the same reason as \el{MuxingApp}.}
\element{int}{DateUTC}{44 61}{\occunique}{-}{contains the production date, measured in nanoseconds relatively to Jan 01, 2001, 0:00:00 GMT+0h}
\end{elementdescription}

\subsection{SeekHead}
The \el{SeekHead} element contains a list of positions of Level 1 elements in the \el{Segment}. Each pair (element id, position) is stored in one \el{Seek} element:

\begin{elementdescription}{The \el{SeekHead} element, \childof{Segment}}{SeekHead}
\masterelement{Seek}{4D BB}{\occmandatory}{One \el{Seek} element contains an EBML-ID and the position within the \el{Segment} at which an element with this ID can be found.}
\end{elementdescription}

\begin{elementdescription}{The \el{Seek} element, \childof{SeekHead}}{Seek}
\element{uint}{SeekID}{53 AB}{\occonce}{-}{The \el{SeekID} element contains the EBML-ID of the element found at the given position}
\element{uint}{SeekPosition}{53 AC}{\occonce}{-}{The \el{SeekPosition} element contains the position relatively to the \el{Segment}'s data at which an element with the ID \valueof{SeekID} can be found.}
\end{elementdescription}

Not all Level 1 elements need to be included. Typical \el{SeekHead}s either include a list of all Level 1 elements, or a list of all Level 1 elements except for \el{Cluster}s \refsec{sec_Cluster}. \el{SeekHead}s can also include references to other \el{SeekHead}s if there is, for example, a small \el{SeekHead} at the beginning of the file and a larger one at its end.

The following picture illustrates the \el{SeekHead} element in a real file. Note that the EBML Tree Viewer replaced Level 1 IDs in \el{SeekID} with their human-readable name:

\pic{Seekhead}

\newpage
\subsection{Tracks}
The \el{Tracks} element contains information about the tracks that are stored in the \el{Segment}, like track type (audio, video, subtitles), the used codec, resolution and sample rate. All tracks shall be described in one (or more, but preferably only one) \el{Tracks} element. 

Each track is described in one \el{TrackEntry}. Theoretically, using the \el{TrackUID}, information about one track could be spread over different \el{TrackEntry}s, the UID would allow to know which track the information applies to, however, it is highly discouraged to stretch the specification like this.

Also, an empty \el{Tracks} element would be rather useless, but should not lead to a parser error since the file can be played if all tracks are defined \emph{somewhere}. Especially pure chapter files might have an empty \el{Tracks} element if the muxer doesn't catch the case that no tracks are present and consequently creates an empty \el{Tracks} element.

An example of a \el{TrackEntry} element can be found on \refpage{pic_header_striping}

\begin{elementdescription}{The \el{Tracks} element, \childof{Segment}}{Tracks}
\masterelement{TrackEntry}{AE}{\occmandatory}{One \el{TrackEntry} element describes one track of the \el{Segment}}
\end{elementdescription}

\begin{elementdescription}{The \el{TrackEntry} element, \childof{Tracks}}{TrackEntry}
\element{uint}{TrackNumber}{D7}{\occveryonce}{-}{defines an identification number of the track. This number cannot be equal to 0. This number is used by the \el{Block} and \el{SimpleBlock} structures.}
\element{uint}{TrackUID}{73 C5}{\occonce}{-}{is a unique identificator of the track within the file. It cannot be equal to 0}
\enumeratedelement{uint}{TrackType}{83}{\occveryonce}{-}{defines the type of a track, i.e. video, audio, subtitle etc.}
\element{bool}{FlagEnabled}{B9}{\occunique}{1}{When \el{FlagEnabled} is 1, track is used}
\element{bool}{FlagDefault}{88}{\occunique}{1}{When \el{FlagDefault} is 1, the track should be selected by the player by default. Obviously, if no video track and/or no audio track has a default flag, one video track and one audio track should be chosen by the player, whereas no subtitle should be enabled if no subtitle has a default flag.}
\element{bool}{FlagForced}{55 AA}{\occunique}{0}{When \el{FlagForced} is 1, the track must be played. When several subtitle tracks are forced, the one matching the audio language should be chose. An example would be a subtitle track that cannot be disabled, like the one you find on the german DVD ``Eiskalte Engel'' when you select english audio. Since this flag can only be used to apply a restriction on digital content, it must be qualified as Digital Restrictions Management.}
\element{bool}{FlagLacing}{9C}{\occunique}{0}{When \el{FlagLacing} is 1, the track may contain laced blocks. A parser that supports all types of lacing \refsec{sec_lacing} can safely ignore this flag.}
\element{uint}{MinCache}{6D E7}{\occunique}{0}{ indicates the number of frames a player must be able to cache during playback. This is for instance interesting if a native MPEG4 file with frames in coding order is played.}
\element{uint}{MaxCache}{6D F8}{\occunique}{-}{indicates the maximum cache size a player needs to cache frames. A value of NULL means that no cache is required.}
\element{uint}{DefaultDuration}{23 E3 83}{\occunique}{-}{This value indicates the number of nanoseconds a frame lasts. This value is applied if no \valueof{Duration} value is indicated for a frame or if lacing \refsec{sec_blocklayout} is used. A value of 0 means that the duration of frames of the track is not necessarily constant (e.g. variable framerate video, or Vorbis audio). \el{DefaultDuration} should be written for each track with a constant frame rate since it makes seeking easier.}
\element{float}{TrackTimecodeScale}{23 31 4F}{\occunique}{-}{Every timecode of a block (\texttt{cluster timecode + block timecode}) is multiplied by this value to obtain the real timecode of a block.}
\element{utf-8}{Name}{53 6E}{\occunique}{-}{A \el{Name} element contains a human-readable name for the track. Note that you can't define which language this track name is in. You have to use Tags \refsec{sec_Tags}) if you want to use several titles in different languages for the same track.}
\element{string}{Language}{22 B5 9C}{\occunique}{eng}{specifies the language of a track, using ISO639-2\footnote{\url{http://lcweb.loc.gov/standards/iso639-2/englangn.html}}. This is NOT necessarily the language of \valueof{Name}, for example a german AC3 track could be called ``German - AC3 5.1'' or ``Deutsch - AC3 5.1'' or ``Allemand AC3 5.1'' etc.}
\element{string}{CodecID}{86}{\occveryonce}{-}{The \el{CodecID} specifies the Codec\footnote{\url{http://matroska.org/technical/specs/codecid/index.html}} which is used to decode the track.}
\element{binary}{CodecPrivate}{63 A2}{\occunique}{-}{\el{CodecPrivate} contains information the codec needs before decoding can be started. An example is the Vorbis initialization packets for Vorbis audio.}
\element{utf-8}{CodecName}{25 86 88}{\occunique}{-}{\el{CodecName} is a human-readable name of the Codec}
\element{uint}{AttachmentLink}{74 46}{\occnomatter}{-}{An \el{AttachmentLink} contains the UID of an attachment that is used by this track.}
\masterelement{Video}{E0}{\occunique}{\el{Video} contains information that is specific for video tracks}
\masterelement{Audio}{E1}{\occunique}{\el{Audio} contains information that is specific for audio tracks}
\masterelement{ContentEncodings}{6D 80}{\occunique}{\el{ContentEncodings} contains information about (lossless) compression or encryption of the track}
\end{elementdescription}

Obviously, the \el{Video} element must be present for video tracks, whereas the \el{Audio} element must be present for audio tracks. Although it doesn't make sense to have both elements in one \el{TrackEntry} element, it wouldn't make a file unplayable.

\begin{elementdescription}{The \el{Video} element, \childof{TrackEntry}}{Video}
\element{uint}{PixelWidth}{B0}{\occonce}{-}{Width of the encoded video track in pixels}
\element{uint}{PixelHeight}{BA}{\occunique}{-}{Height of the encoded video in pixels}
\element{uint}{PixelCropBottom}{54 AA}{\occunique}{0}{Number of Pixels to be cropped from the bottom}
\element{uint}{PixelCropTop}{54 BB}{\occunique}{0}{Number of Pixels to be cropped from the top}
\element{uint}{PixelCropLeft}{54 CC}{\occunique}{0}{Number of Pixels to be cropped from the left}
\element{uint}{PixelCropRight}{54 DD}{\occunique}{0}{Number of Pixels to be cropped from the right}
\element{uint}{DisplayWidth}{54 B0}{\occunique}{\valueof{PixelWidth}}{Width of the video during playback}
\element{uint}{DisplayHeight}{54 BA}{\occunique}{\valueof{PixelHeight}}{Height of the video during playback}
\element{uint}{DisplayUnit}{54 B2}{\occunique}{0}{Unit \valueof{DisplayWidth} and \valueof{DisplayHeight} is measured in. This can be 0$\rightarrow$pixels, 1$\rightarrow$centimeters, 2$\rightarrow$inches}
\end{elementdescription}

\valueof{PixelCropxxxx} is applied on \valueof{Pixelxxx}, so the output is cropped after decoding, but before stretching it to the dimensions indicated with \valueof{Displayxxxx}.

\begin{elementdescription}{The \el{Audio} element, \childof{TrackEntry}}{Audio}
\element{float}{SamplingFrequency}{B5}{\occunique}{8 kHz}{Indicates the sample rate the track is encoded at in Hz}
\element{float}{Output-\\SamplingFrequency}{78 B5}{\occunique}{-}{Indicates the sample rate the track must be played at in Hz. The default value of this element is equal to \valueof{SamplingFrequency}.}
\element{uint}{Channels}{9F}{\occunique}{1}{Number of channels of the audio track}
\element{uint}{BitDepth}{62 64}{\occunique}{-}{Bits per sample, this is usually used with PCM-Audio.}
\end{elementdescription}

\begin{elementdescription}{The \el{ContentEncodings} element, \childof{TrackEntry}}{ContentEncodings}
\masterelement{ContentEncoding}{62 40}{\occmandatory}{A \el{ContentEncoding}-element describes one compression or encryption that has been used on this track.}
\end{elementdescription}

\begin{elementdescription}{The \el{ContentEncoding} element, \childof{ContentEncodings}}{ContentEncoding}
\element{uint}{ContentEncoding-\\Order}{50 31}{\occunique}{0}{Tells when to decode according to this pattern. The decoder starts with the \el{ContentEncoding} that has the highest \el{ContentEncodingOrder}.}
\enumeratedlongelement{uint}{ContentEncoding-\\Scope}{ContentEncodingScope}{50 32}{\occunique}{1}{Defines which parts of the track are compressed or encrypted this way}
\element{uint}{ContentEncoding-\\Type}{50 33}{\occunique}{0}{Describes which type of encoding is described. 0 $\rightarrow$ compression, 1 $\rightarrow$ encryption}
\masterelement{ContentCompression}{50 34}{\occunique}{If \el{ContentEncodingType=0}, this element describes how it is compressed}
\masterelement{ContentEncryption}{50 35}{\occunique}{If \el{ContentEncryption=1}, this element describes how it is encrypted}
\end{elementdescription}

The \el{ContentEncoding} element allows to apply not only encryption, but also lossless compression to a track. This can be used to compress text subtitles, but also to remove sync headers from audio packets. For example, each AC3 frame starts with \texttt{0B 77}, and there is no real point in saving those two bytes for each frame in a \Matroska file. For a simple AC3 file, this does make sense because there it can be used to find a new frame start if data is damaged.

\begin{elementdescription}{The \el{ContentCompression} element, \childof{ContentEncoding}}{ContentCompression}
\enumeratedelement{uint}{ContentCompAlgo}{42 54}{\occunique}{0}{The \el{ContentCompAlgo} element says which algorithm was used for this compression.}
\element{binary}{ContentCompSettings}{42 55}{\occunique}{-}{Contains settings that are required for decompression. These settings are specific for each compression algorithm. For example, it contains the striped header bytes when \valueof{ContentCompAlgo}=3 \refpage{pic_header_striping}. }
\end{elementdescription}


\begin{enumtable}{Values of \el{TrackType}, \childof{TrackEntry}}{TrackType}
\enumitem{0x01}{track is a video track}
\enumitem{0x02}{track is an audio track}
\enumitem{0x03}{track is a complex track, i.e. a combined video and audio track}
\enumitem{0x10}{track is a logo track}
\enumitem{0x11}{track is a subtitle track}
\enumitem{0x12}{track is a button track}
\enumitem{0x20}{track is a control track}
\end{enumtable}

\begin{enumtable}{Bits in \el{ContentEncodingScope}, \childof{ContentEncoding}}{ContentEncodingScope}
\enumitem{1}{all frames}
\enumitem{2}{the track's \el{CodecPrivate}}
\enumitem{4}{the \el{ContentCompression} in the next \el{ContentEncoding} (next as in next in decoding order)}
\end{enumtable}

%\newpage
% new page because this text + picture takes one page anyway
\parbox{\linewidth}{
Here is one example of a possible \el{TrackEntry} element: A DTS-audio track that is using header striping. The \el{ContentCompSettings} element contains the four bytes each DTS frame starts with.

\label{pic_header_striping}
%\pic{matroska_header_striping.png}
}

\begin{enumtable}{Values of \el{ContentCompAlgo}, \childof{ContentCompression}}{ContentCompAlgo}
\enumitem{0}{zlib}
\enumitem{1}{bzlib}
\enumitem{2}{lzo1x}
\enumitem{3}{header striping}
\end{enumtable}


\newpage
\subsection{Cluster}
\label{sec_Cluster}
A \el{Cluster} contains multimedia data and usually spans over a range of a few seconds. The following picture shows a typical cluster:

\pic{Cluster}

Although sticking to this order of the elements is not mandatory, it is recommended not to have any non-\el{BlockGroup/SimpleBlock} after the first \el{BlockGroup/SimpleBlock}, because it's bad if the entire cluster must be read before it can be used just because the timecode is stored at the end.

\begin{elementdescription}{The \el{Cluster} element, \childof{Segment}}{Cluster}
\element{uint}{TimeCode}{E7}{\occunique}{0}{The Cluster timecode is the timecode all block timecodes are indicated relatively to.}
\element{uint}{Position}{A7}{\occunique}{-}{The \el{Position} element indicates the position of the beginning of its parent element inside its grand parent element. This can help to resync in case of damaged data, but is of no use if no data is damaged.}
\element{uint}{PrevSize}{AB}{\occunique}{-}{Indicates the size of the preceding cluster in bytes. This helps to seek backwards, and to find the preceding cluster, without having to look at \el{Metaseek} or \el{Cue} data. This is also helpful to resync, e.g. if the EBML-ID of the preceding \el{Cluster} is damaged.}
\masterelement{BlockGroup}{A0}{\occnomatter}{Contains a \el{Block} along with some attached information like references}
\element{binary}{SimpleBlock}{A3}{\occnomatter}{-}{This is a \el{Block} \refpage{sec_blocklayout} without additional attached information. Since a \el{SimpleBlock} does not require a \el{BlockGroup} around it, it causes less overhead. \el{SimpleBlock} is \Matroska {\color{red} v2}.}
\end{elementdescription}

\begin{elementdescription}{The \el{BlockGroup} element, \childof{Cluster}}{BlockGroup}
\element{binary}{Block}{A1}{\occveryonce}{-}{contains data to be replayed. See page \pageref{sec_blocklayout} for details.}
\element{int}{ReferenceBlock}{FB}{\occnomatter}{-}{Timecode of a frame, relative to the \el{Block}'s timecode, of a frame that needs to be decoded before this \el{Block} can be decoded.}
\element{int}{BlockDuration}{9B}{\occunique}{-}{Indicates the scaled duration of the \el{block}. If this value is not written,
it is assumed to be (1) the difference \texttt{ <timecode of next block of the same stream> - <timecode>} (2) equal to \el{DefaultDuration} (for the last block of each stream). 

As a consequence, the \el{Duration} element is mandatory for every \el{block} of subtitle tracks, unless a subtitle is indeed supposed to disappear only directly before the next one appears. But even then it is recommended to write \el{Duration}.}
\end{elementdescription}

\newpage
\subsection{Cues}
The \el{Cue}s element contains information helpful (but not necessary) for seeking. Each piece of information, called a \el{CuePoint}, contains a timestamp, and a list of pairs (track number, (cluster position[, block number within cluster])). Generally, a \el{CuePoint} should only point to keyframes.

\pic{Cues}

\begin{elementdescription}{The \el{Cues} element, \childof{Segment}}{Cues}
\masterelement{CuePoint}{BB}{\occmandatory}{One \el{CuePoint} contains one entry point (or a list of entry points with one point for one track) for one timecode.}
\end{elementdescription}

\begin{elementdescription}{The \el{CuePoint} element, \childof{Cues}}{CuePoint}
\element{uint}{CueTime}{B3}{\occveryonce}{-}{The timecode of the \el{Cluster}s or \el{Block}s that are referred to by this \el{CuePoint}}
\masterelement{CueTrackPositions}{B7}{\occmandatory}{A position where a \el{Cluster} or \el{Block} can be found with the timecode \valueof{CueTime}.}
\end{elementdescription}

\begin{elementdescription}{The \el{CueTrackPositions} element, \childof{CuePoint}}{CueTrackPositions}
\element{uint}{CueTrack}{F7}{\occverymandatory}{-}{Track for which a position is given. This track number is the same as \el{TrackEntry} \reftab{tab_TrackEntry}::\el{TrackNumber}.}
\element{uint}{CueClusterPosition}{F1}{\occverymandatory}{-}{The position of the cluster the referred block is found in. This position is relative to the \el{Segment}'s \reftab{tab_Segment} data section.}
\element{uint}{CueBlockNumber}{53 78}{\occunique}{-}{The block with timecode \valueof{CueTime} is the \valueof{CueBlockNumber}-th \el{Block/SimpleBlock} inside the \el{Cluster} at position \valueof{CueClusterPosition}.}
\end{elementdescription}

\newpage
\subsection{Chapters - Editions and ChapterAtoms}
The \el{Chapters} element contains a list of all editions and chapters found in this \el{Segment}. Chapters in \Matroska files are more powerful than chapters on DVDs, their handling is, however, way more complex.

\begin{elementdescription}{The \el{Chapters} element, \childof{Segment}}{Chapters}
\masterelement{EditionEntry}{45 B9}{\occmandatory}{One \el{EditionEntry} describes one Edition. Just like with \el{TrackEntry} \reftab{tab_TrackEntry}, theoretically you could spread information about one Edition over different \el{EditionEntry}s and use \valueof{EditionUID} to find out which edition the \el{EditionEntry} is referring to, but it's highly discouraged.}
\end{elementdescription}

An edition contains one set of chapter definitions, so having several editions means having several sets of chapter definitions. This case is used when using this as a playlist - playing one chapter after the other while having gaps between the chapters.

\begin{elementdescription}{The \el{EditionEntry} element, \childof{Chapters}}{EditionEntry}
\element{uint}{EditionUID}{45 BC}{\occunique}{-}{\valueof{EditionUID} is the UID of the edition. This element is mandatory if you want to apply one or more titles to an edition}
\element{bool}{EditionFlagHidden}{45 BD}{\occunique}{0}{When \valueof{EditionFlagHidden} is 1, this edition should not be available via the user interface}
\element{bool}{EditionFlagDefault}{45 DB}{\occunique}{0}{When \valueof{EditionFlagDefault} is 1, this edition should be selected by the player as default}
\element{bool}{EditionFlagOrdered}{45 DD}{\occunique}{0}{When \valueof{EditionFlagOrdered} is 1, this edition contains a playlist. When \valueof{EditionFlagOrdered} is 0, it contains a simple DVD like chapter definition.}
\masterelement{ChapterAtom}{B6}{\occmandatory}{One \el{ChapterAtom} contains the definition of one chapter. This element is the only one in \Matroska files that can contain itself recursively - in this case to define subchapters.}
\end{elementdescription}

\parbox{\linewidth}{The following picture shows an ordered edition:

\pic{chapters}}

\begin{elementdescription}{The \el{ChapterAtom} element, \childof{EditionEntry}, \childof{ChapterAtom}}{ChapterAtom}
\element{uint}{ChapterUID}{73 C4}{\occonce}{-}{The UID of this chapter. It must be unique within the file.}
\element{uint}{ChapterTimeStart}{91}{\occunique}{0}{The \emph{unscaled} timecode the chapter starts at. As the value is unsigned, a chapter cannot start earlier than at timecode 0, even whereas timecodes up to -30.000 are possible for multimedia data.}
\element{uint}{ChapterTimeEnd}{92}{\occunique}{-}{The \emph{unscaled} timecode the chapter ends at. The default value is the start of the next chapter or the end of the parent chapter or the end of the segment, whatever exists, in that order.}
\element{bool}{ChapterFlagHidden}{98}{\occunique}{0}{When \valueof{ChapterFlagHidden} is 1, the chapter should not be visible in the user interface, but should be played back normally.}
\element{bool}{ChapterFlagEnabled}{45 98}{\occunique}{1}{When \valueof{ChapterFlagEnabled} is 0, the chapter should be skipped by the player}
\element{char[16]}{ChapterSegmentUID}{6E 67}{\occunique}{-}{This element can only occur if \valueof{EditionFlagOrdered}=1. The \el{Segment} of which the UID is \valueof{ChapterSegmentUID} is used instead of the current \el{Segment}. Obviously, this \el{Segment} should be easy to find, like when it is the first segment of a file in the same directory.}
\element{uint}{ChapterSegment\\-EditionUID}{6E BC}{\occunique}{-}{The edition to use inside the \el{Segment} selected via \el{ChapterSegmentUID}. The timecodes \valueof{ChapterTimeStart} and \valueof{ChapterTimeEnd} refer to playback timecodes of that edition, i.e. the timecodes are relative to that playlist. This is called ``nested Editions'' and is NOT SUPPORTED by \emph{Haali Media Splitter}.}
\masterelement{ChapterTracks}{8F}{\occunique}{Contains a list of tracks the chapter applies to.}
\masterelement{ChapterDisplay}{80}{\occnomatter}{Contains all chapter titles}
\end{elementdescription}

A useful application for the \el{ChapterFlagHidden} element in connection with ordered editions is the following: You have a couple of episodes of a series, but want to save space by only saving the intro and outtro once. You create one playlist (ordered edition) per episode, and another playlist playing all episodes in a row. Whereas in the first case you might want to play intro and outtro for each episode, you might not want to do that in the second case. 

If you don't want to make the three parts intro - movie - outtro selectable via the user interface when playing single episodes, you call the intro-chapter ``Episode - blah'' and hide the movie- and the outtro chapter using \valueof{ChapterFlagHidden}=1. Then, the playlist playing all episodes would be \textit{intro - episode 1 - episode 2 - ... - last episode - outtro}, whereas the other playlists would be \textit{intro - episode \textsc{n} - outtro}. The name of the intro chapter would be set to ``Episode \textit{n}''.

\begin{elementdescription}{The \el{ChapterTracks} element, \childof{ChapterAtom}}{ChapterTracks}
\element{uint}{ChapterTrackNumber}{89}{\occmandatory}{-}{One number of a track a chapter is used with.}
\end{elementdescription}

\begin{elementdescription}{The \el{ChapterDisplay} element, \childof{ChapterAtom}}{ChapterDisplay}
\element{utf-8}{ChapString}{85}{\occunique}{-}{A title of a chapter}
\element{string}{ChapLanguage}{43 7C}{\occnomatter}{eng}{The language of \valueof{ChapString} as defined in ISO639-2\footnotemark\footnotetext{\url{http://lcweb.loc.gov/standards/iso639-2/englangn.html\#two}}}
\element{utf-8}{ChapCountry}{43 7E}{\occnomatter}{-}{A country the title is used in. For example, a german title in Germany might be different than the title used in Austria.}
\end{elementdescription}

\newpage
\subsection{Attachments}

Theoretically, any file type can be attached to a \Matroska file, however, this possibility is usually used to attach pictures like CD covers or fonts required to display a subtitle track correctly. Obviously, attaching executable files would allow for \Matroska files to contain viruses - a scenario that is not exactly the indended application of attachments or anything else \Matroska is capable of.

\begin{elementdescription}{The \el{Attachments} element, \childof{Segment}}{Attachments}
\masterelement{AttachedFile}{61 A7}{\occmandatory}{Describes and contains one attached file}
\end{elementdescription}

\begin{elementdescription}{The \el{AttachedFile} element, \childof{Attachments}}{AttachedFile}
\element{utf8}{FileDescription}{46 7E}{\occunique}{-}{A human-readable description of the file}
\element{utf8}{FileName}{46 6E}{\occunique}{-}{The name that should be proposed by a demuxer when extracting the file}
\element{string}{FileMimeType}{46 60}{\occunique}{-}{MIME type of the file, like ...}
\element{binary}{FileData}{46 5C}{\occunique}{-}{The file itself}
\element{uint}{FileUID}{46 AE}{\occonce}{-}{The UID of that file, just like \el{TrackUID}, \el{ChapterUID} etc. The UID is required if a \el{TrackEntry} \reftab{tab_TrackEntry} wants to refer to this Attachment.}
\end{elementdescription}

\newpage
\subsection{Tags}
\label{sec_Tags}

\begin{elementdescription}{The \el{Tags} element, \childof{Segment}}{Tags}
\masterelement{Tag}{73 73}{\occmandatory}{One \el{Tag} element describes one Tag}
\end{elementdescription}

\el{Tags} provide additional information\footnote{\url{http://www.matroska.org/technical/specs/tagging/index.html}} not important for replay. A \el{Tags} element contains a number of \el{Tag} elements. Each \el{Tag} element contains a list of UIDs (usually \el{TrackUID}s or \el{EditionUID}s), and a list of \el{SimpleTag}s, each one containing a name and a value:

\pic{Tags}

If no \el{Target}s are specified, then the \el{Tag} is a global \el{Tag} refering to the entire \el{Segment}. Of course, two different \el{Tag} elements can contain identical \el{Targets}.

\begin{elementdescription}{The \el{Tag} element, \childof{Tags}}{Tag}
\masterelement{Targets}{63 C0}{\occunique}{Describes which elements a Tag applies to}
\masterelement{SimpleTag}{67 C8}{\occmandatory}{Each \el{SimpleTag} contains one tag that applies to each target in \el{Targets}}
\end{elementdescription}

Note that there is nothing like a \el{TagUID}.

\begin{elementdescription}{The \el{Targets} element, \childof{Tag}}{Targets}
\enumeratedelement{uint}{TargetTypeValue}{68 CA}{\occunique}{50}{This number describes the logical level of the object the Tag refers to}
\element{utf-8}{TargetType}{63 CA}{\occunique}{-}{A string describing the logical level of the object the Tag is refering to}
\element{uint}{TrackUID}{63 C5}{\occnomatter}{-}{The UID of a track the tag is referring to}
\element{uint}{EditionUID}{63 C9}{\occnomatter}{-}{The UID of an edition the tag is referring to. Note that this is the only way to apply titles to an edition}
\element{uint}{ChapterUID}{63 C4}{\occnomatter}{-}{The UID of a chapter the tag is referring to}
\element{uint}{AttachmentUID}{63 C6}{\occnomatter}{-}{The UID of an attachment the tag is referring to}
\end{elementdescription}

\begin{elementdescription}{The \el{SimpleTag} element, \childof{Tag}}{SimpleTag}
\element{utf-8}{TagName}{45 A3}{\occverymandatory}{-}{Name of the tag.}
\element{string}{TagLanguage}{44 7A}{\occunique}{und}{\valueof{TagLanguage} is the language of \valueof{TagName}. Note that the default here is `und', whereas the default track / chapter title language is `eng'.}
\element{bool}{TagOriginal}{44 84}{\occunique}{1}{When 1, this title and language is the original title given to the item}
\element{utf-8}{TagString}{44 87}{\occunique}{-}{The value of the tag when it is a string}
\element{binary}{TagBinary}{44 85}{\occunique}{-}{The `value' of the tag when it's a binary tag}
\end{elementdescription}

\subsubsection{A few common Tags}
\begin{itemize}
\item \f{TITLE}, Target: EditionUID: used to define names for Editions. This is exactly what you can see in the screenshot above.
\item \f{BPS}, Target: TrackUID: used to define the bitrate of a track
\item \f{FPS}, Target: TrackUID: used to define the framerate of a track
\end{itemize}

\newpage
\section{\Matroska block Layout and Lacing}
\subsection{Basic layout of a Block}
\label{sec_blocklayout}
A \Matroska block has the following format:
\lstset{emph={vint,sint16,int8,svint},emphstyle=\color{blue}\textbf,identifierstyle=\textbf}
\begin{lstlisting}
BLOCK {
  vint TrackNumber
  sint16 Timecode  // relative to Cluster timecode
  int8 Flags     // lacing, keyframe, discardable
  if (lacing) {
    int8 frame_count-1
    if (lacing ==  EBML lacing) {
       vint size[0]
       svint size[1..frame_count-2]
    } else 
    if (lacing == Xiph lacing) {
      int8 size[size of <leading (frame_count-1) frames> / 255 + 1]
    }
  }
  int8[] data 
}
\end{lstlisting}
The following bits are defined for \el{Flags}:
\begin{verbatim}  Bit  0x80: keyframe:
              No frame after this frame can reference any frame before
              this frame and vice versa (in AVC-words: this frame is an
              IDR frame). The frame itself doesn't reference any other
              frames.
  Bits 0x06: lace type
              00 - no lacing
              01 - Xiph lacing
              11 - EBML lacing
              10 - fixed-size lacing
  Bit 0x08 : invisible: duration of this block is 0
  Bit 0x01 : discardable: this frame can be discarded if the decoder
             is slow
\end{verbatim}
The following flags are only defined for Matroska v2 and can thus only be used in a \el{SimpleBlock}: \textsl{keyframe, invisible, discardable}.
The type of lacing in use defines how the \el{size} values are to be read.
\subsection{Lacing}
\label{sec_lacing}
Lacing is a technique that allows to store more than one atom of data (like one
audio frame) in one block, with the goal to decrease overhead, without losing
the ability to separate the frames in a lace later again.\\[0.3cm]
Generally, the size of the last frame in a Lace is not stored, as it can be derived
from the total block size, the size of the block header and the sum of the sizes
of all other frames.\\
Frame duration values are not preserved! That means, it is highly recommended \f{not}
to use lacing if the frame duration is not constant, like Vorbis audio.
\subsubsection{Xiph Lacing}
\label{xiphlacing}
The size of each frame is coded as a sum of int8. A value smaller than 255
indicates that the next value refers to the next frame.\\[0.2cm]
\f{Example}\\
\texttt{size = \{ 187, 255, 255, 120, 255, 0, 60 \}} means that there are 4 frames with \texttt{187, 630, 255, 60} bytes.
\subsubsection{EBML Lacing}
Size of first frame (''frame \texttt{0}``) of a lace = \texttt{size[0]}\\
Size of frame \texttt{i} of a lace: \texttt{size[i] - size[i-1]}
\subsubsection{Fixed Lacing}
\label{fixedlacing}
Fixed Lacing is used if all frames in a lace have the same size. Examples are
AC3 or DTS audio. In this case, knowing the number of frames is enough to
calculate the size of one frame. Consequently, there are no \texttt{size} values.
\newpage
\section{Overhead of \Matroska files}
The scope of this section is explaining how to predict the overhead of a \Matroska
file before muxing, and without analysing any of the source files excessively. This
section assumes that \el{BlockGroups} and \el{Blocks} are used, and that no \el{SimpleBlocks}
are used. If you want to estimate overhead of files that use \el{SimpleBlocks}, you get about
the same overhead as with \el{Blocks} without \el{BlockDuration}, \el{ReferenceBlock} or \el{BlockGroup}.
\subsection{Overhead of \el{BlockGroups}}
First, here again the layout of a typical \el{BlockGroup}
\begin{verbatim}
  BlockGroup <size>
     Block <size> <number, flag, timecode>
     [ Reference <size> <val> ]
\end{verbatim}
The EBML identication for \el{Block}s and \el{BlockGroup}s are 1 byte each,
so that the structure above, not counting \el{Reference}s, takes:
\begin{itemize} \item BlockGroup < 128 bytes: \f{8 bytes}
\item BlockGroup < ~16kbytes: \f{10 bytes}
\item BlockGroup < ~2MBytes: \f{12 bytes}
\end{itemize}
\el{BlockGroup}s larger than 2MBytes are extremely unlike, and even \el{BlockGroup}s
larger than 16kBytes won't occur often, compared to \el{BlockGroup}s between 128 bytes
and 16 kBytes. That means, assuming an overhead of 10 bytes for \el{BlockGroup}s without
\el{References} usually results in a good approximation.
\subsubsection{video}
In a typical video stream, there are a lot of frames with 1 \el{Reference}
(P-Frames, Delta-Frames), and a few keyframes. Typical rations are 100:1.
There might also be frames with 2 \el{References} (B-Frames), e.g. native MPEG4 streams.
Assuming a ratio of 66:33:1 for B:P:K, and assuming a bitrate far below 3,2 MBit/s
(meaning that typical B- and P-frames are smaller than 16 kB), that causes about 15
bytes of overhead per frame. If there are no B-Frames, there are about 13 bytes per frame.\\[0.3cm]
\f{Example}: 2 hours, 25 fps.\\
The video stream will cause around 2,3 MB of overhead.

\subsubsection{audio - without lacing}
As audio does usually not have any \el{Reference}s (all audio frames are keyframes),
one audio frame will take 8 or 10 bytes of overhead. For MP3, AC3, DTS and AAC, 
frames causing 8 bytes of overhead are unlikely. They are more likely for Vorbis.\\[0.3cm]
\f{Example:} MP3 audio, 24ms per frame, duration: 2h\\
This stream will cause ~3MB of overhead.

\subsubsection{audio - with lacing}
\f{1. CBR+CFR: fixed lacing}\\
In this case, \textsl{fixed lacing} (see section \ref{fixedlacing}) is used. With
fixed lacing, the overhead is
the normal \el{BlockGroup} overhead, plus 1 byte for the lace header. Assuming
that \el{BlockGroups} are not larger than 16k, that means that the overhead
per frame is equal to \texttt{11 / frame\_count}\\[0.3cm]
\f{Example:} AC3 audio, 448 kbps, 1792 bytes per frame, 32ms per frame\\
1.)  8 frames per lace.\\
overhead for one frame = \texttt{11/8 = 1,375} bytes = \texttt{1 byte / 23,3 ms}.\\
2.)  9 frames per lace.\\
overhead for one frame = \texttt{11/9 = 1,222} bytes = \texttt{1 byte / 26,2 ms}.\\
3.) 10 frames per lace.\\
overhead for one frame = \texttt{13/10 = 1,3 } bytes = \texttt{1 byte / 24,6 ms}.\\[0.3cm]
An AC3 stream of 2 hours with 9 frames per lace will cause ~270kB of overhead.\\[0.5cm]
\f{2. no CBR, but almost all frames smaller than 255 bytes: XIPH lacing}\\
In this case, XIPH lacing (see section \ref{xiphlacing}) is used, meaning that the overhead of
a \el{BlockGroup} is
equal to \texttt{normal BlockGroup overhead + frame\_count}, meaning that the overhead
per frame is about \texttt{(11+frame\_count)/frame\_count}, if there are \texttt{frame\_count}
frames in each lace. Again, if the \el{BlockGroup}s are larger than 16kBytes, then
the overhead is \texttt{(13+frame\_count)/frame\_count}.\\In other words, the ratio in
\texttt{bytes / frame} will always be between about \texttt{1,2} and \texttt{2,5} for
audio streams with mainly small frames.\\[0.2cm]
Although XIPH lacing is also defined for larger frames, EBML lacing is usually more
effective then.\\[0.5cm]
\f{3. otherwise: EBML lacing}
Assuming that the difference in size between 2 consecutive frames is smaller
than 8191, 1 or 2 bytes are needed to code the size of each frame, additionally
to the normal \el{BlockGroup} overhead.\\[0.3cm]
As a result, we get 3 possible estimations:\\[0.2cm]
\f{a) worst case} 
That means, a lace with \texttt{frame\_count} frames using EBML lacing will
cause not more than \texttt{((11 or 13)+2*frame\_count)/frame\_count} bytes of
overhead per frame.\\[0.2cm]
\f{Example 1:} 16 frames per lace, \el{BlockGroup} > 16kB, worst case:\\
\texttt{overhead <= (13 + 2*16)/16 = 2,8 bytes / frame}.\\
\f{Example 2:} 8 frames per lace, \el{BlockGroup} < 16kB, worst case:\\
\texttt{overhead <= (11 + 2*8)/8 = 3,4 bytes / frame}.\\[0.3cm]
\f{b) best case}
The best case is obviously that 2 consecutive frames differ by not more than 62
bytes. In that case, one byte is needed to code the size of one frame.
However, the first frame might need to bytes, if it is larger than 126
bytes.\\[0.2cm]
\f{Example 1:} 16 frames per lace, \el{BlockGroup} > 16kB, best case:\\
\texttt{overhead <= (13 + 1*16)/16 = 1,8 bytes / frame}.\\
\f{Example 2:} 8 frames per lace, \el{BlockGroup} < 16kB, best case:\\
\texttt{overhead <= (11 + 1*8)/8 = 2,4 bytes / frame}.\\[0.3cm]
\f{c) average case}
This is the case you need for optimal overhead prediction. Unfortunately,
the average case depends on the compression format of the corresponding
audio track, its bitrate, maybe even the encoder that has been used. The
easiest way to gather data on the average case of EBML lace header overhead
is to simulate the lace results of different files that are likely to be
used. Candidates are MPEG 1/2/4 audio and Vorbis, but not AC3 or DTS.\\
I have run a simulation with the following file types:\\
MPEG 1 Layer 3 (128 and 192 kbps, 48 kHz), HE-AAC (224 kbps and 96 kbps, 44,1 kHz),
LC-AAC (268 kbps, 44,1 kHz)\\[0.2cm]
The results obtained from those files are discussed on the following
pages. The lace behaviour simulation has been run using \texttt{mls}\footnote{\url{http://www-user.tu-chemnitz.de/~noe/Video-Zeug/mls/}} (
short for 'matroska lace simulator'). Note that it would be required to run the simulation and to evaluate the
results as follows for each audio format, in each bitrate, maybe even
with each encoder, for which results as accurate as possible shall be
predicted.

The results for the lace header size are as follows:

\begin{tabular}{@{}l@{ @ }r@{ kbps\hspace*{3mm}}|rrrrrrrrr@{}}
\multicolumn{2}{c|}{ } & \multicolumn{9}{c}{Lace header overhead per frame @ <x> Frames per lace} \\
\multicolumn{2}{c|}{Audio Format} & 4 & 8 & 12 & 16 & 24 & 32 & 48 & 64 & 96 \\
\hline MP3 & 128  & 1,39 & 1,29 & 1,26 & 1,24 & 1,22 & 1,22 & 1,21 & 1,20 &1,20 \\
MP3 & 192 & 1,50 & 1,41 & 1,38 & 1,37 & 1,36 & 1,35 & 1,34 & 1,34 & 1,33 \\
HE-AAC & 224 & 1,39 & 1,29 & 1,25 & 1,24 & 1,22 & 1,21 & 1,20 & 1,20 & 1,20 \\
HE-AAC & 64 & 1,34 & 1,23 & 1,19 & 1,18 & 1,16 & 1,15 & 1,14 & 1,14 & 1,13 \\
LC-AAC & 268 & 1,31 & 1,19 & 1,16 & 1,14 & 1,12 & 1,11 & 1,10 & 1,09 & 1,09
\end{tabular}

Applications using \texttt{libmatroska} for \Matroska file creation are using 8 frames per lace. As a consequence, the overhead for a track using EBML lacing can be predicted to an acceptable accuracy if the audio format
is known.\\As you can also see, larger laces hardly affect the overhead caused by the lace headers of \el{Block}s from a certain size on.

However, larger laces mean fewer \el{Block}s and thus fewer \el{BlockGroup}s, so the total overhead per frame, including the overhead caused by overhead outside of the \el{Blocks}, is worth a look. Here are the results with
the same test files as above

\begin{tabular}{@{}l@{ @ }r@{ kbps\hspace*{3mm}}|rrrrrrrrr@{}}
\multicolumn{2}{c|}{ } & \multicolumn{9}{c}{Overhead per frame @ <x> Frames per lace} \\
\multicolumn{2}{c|}{Audio Format} & 4 & 8 & 12 & 16 & 24 & 32 & 48 & 64 & 96 \\
\hline
MP3 & 128 & 4,14 & 2,67 & 2,17 & 1,93 & 1,68 & 1,56 & 1,48 & 1,41 & 1,33 \\
MP3 & 192 & 4,25 & 2,79 & 2,30 & 2,06 & 1,81 & 1,75 & 1,61 & 1,54 & 1,47\\
HE-AAC & 224 & 4,14 & 2,66 & 2,23 & 2,05 & 1,76 & 1,62 & 1,48 & 1,40 & 1,33\\
HE-AAC & 64 & 4,09 & 2,61 & 2,11 & 1,86 & 1,62 & 1,49 & 1,40 & 1,34 & 1,27\\
LC-AAC & 268 & 4,06 & 2,57 & 2,07 & 1,82 & 1,66 & 1,51 & 1,37 & 1,30 & 1,22
\end{tabular}

Now lets take the 2nd table and find out how much overhead that means in a real movie of 2 hours.

In the case of the mp3 files used in that example, one frame lasts 24ms. In the case of our LC-AAC file, one frame lasts 23,22 ms, and for the HE-AAC file we get 46,44ms.

Thus a file of 2 hours will have the following number of frames:\\
MP3 - 300,000\\LC-AAC - 310,000\\HE-AAC - 155,000.

First, lets use the default setting of \texttt{libmatroska} (8 frames per lace) and calculate the overhead a muxing app using \texttt{libmatroska} would cause when muxing those files into a movie:

\begin{itemize}\item \f{MP3 @ 128}: overhead = 300,000 * 2,67 = 801,000 bytes
\item \f{MP3 @ 192}: overhead = 300,000 * 2,79 = 837,000 bytes
\item \f{HE-AAC @ 224}: overhead = 155,000 * 2,66 = 412,300 bytes
\item \f{LC-AAC @ 268}: overhead = 310,000 * 2,57 = 796,700 bytes\end{itemize}
With 24 frames per lace, an MP3 block would have a duration of 576ms, an HE-AAC block even about 1 second. That means, when seeking in a file, an awkward impression of the audio being missing for a moment could occur. Thus, larger
laces than 1 second are highly discouraged. Nevertheless, let's analyze the overhead in our file for laces of 24 and 96 frames each, and compare the overhead to the one caused by \texttt{libmatroska}. Here is the corresponding table:

\begin{tabular}{@{}l@{ @ }r@{ kbps\hspace*{3mm}}|rrr@{}}
\multicolumn{2}{c|}{ } & \multicolumn{3}{c}{Frames per lace} \\
\multicolumn{2}{c|}{Audio Format} & 8 & 24 & 96 \\
\hline
MP3 & 128 & 782kB & 492kB & 389kB \\
MP3 & 192 & 817kB & 530kB & 430kB\\
HE-AAC & 224 & 402kB & 266kB & 201kB \\
HE-AAC & 64 & 395kB & 245kB & 192kB\\
LC-AAC & 268 & 778kB & 502kB & 369kB
\end{tabular}

As you can see, putting 24 frames in one block, compared to 8 frames,
saves some overhead. However, putting 96 frames in one \el{Block} instead of
24 saves less overhead than 24 compared to 8. As 96 frames per lace will
usually cause uncomfortable seeking, it is recommended not to put more than
about 24 frames in one \el{Block}.
\newpage
\subsection{Overhead of \el{Cluster}s}
Although most of the overhead is caused by \el{BlockGroup}s, the amount of overhead
caused by \el{Clusters} themselves is noticeable as well.\\[0.2cm]
Here again the basic layout of a \el{Cluster}:
\begin{verbatim} Cluster <size>
   [ CRC32 ] 
   TimeCode <size> <timecode>
   [ PrevClusterSize <size> <prevsize> ]
   [ Position <size> <position> ]
   { BlockGroup }
\end{verbatim}   
First, some conventions:
\begin{itemize} \item each \el{Cluster} has a size between 16kB and 2MB
\item each \el{Cluster} may begin between 16MB and 4GB
\end{itemize}
As typical movie files are designed to fit on 1 or 2 CDs, or 2 or 3 of
them fill one DVD, point 2 will be true for most of the clusters in 
typical files.\\[0.2cm]
With the abovementioned restrictions on \el{Cluster}s, the overhead
inside one Cluster will be:
\begin{itemize}
\item \el{Cluster} ID + <size>: 7 bytes
\item \el{CRC32}: 6 bytes
\item \el{Timecode}: 5 bytes
\item \el{PrevClusterSize}: 5 bytes
\item \el{Position}: 5 bytes
\item \el{Seekhead} entry for \el{Cluster}: 17 bytes
\end{itemize}
Depending on the muxing settings, the overhead caused by one \el{Cluster}
will be between 12 and 45 bytes. \\[0.2cm]
\f{Example}: Assuming a size of 1 MB per \el{Cluster},
that means an overhead rate of 0,001\% - 0,005\%, or up to 100 kB in a file of 2GB.
\newpage
\subsection{Overhead caused by \texttt{Cues}}
Here again the layout of a \el{CuePoint}:
\begin{verbatim}
  CuePoint <size>
    CueTime <size> <time>
    { CueTrackPosition <size>
        CueClusterPosition <size> <position>
        CueTrack <size> <track>
        [ CueBlockNumber <size> <block number> ] 
    }
\end{verbatim}
Assuming that a \el{CuePoint} only points into one certain track,
the overhead is:
\begin{itemize}
\item CuePoint: 2 bytes
\item   CueTime: 5 bytes
\item   CueTrackPosition: 2 bytes
\item     CueClusterPosition: 6 bytes
\item     CueTrack: 3 bytes
\item     CueBlockNumber: 4 bytes
\end{itemize}
Total: \texttt{22 bytes}.\\[0.3cm]
\f{Example:} Assuming that there is a \el{CuePoint} each 4 seconds (1 keyframe
in 100 frames), this adds on overhead of \texttt{0,22 bytes / frame}\\[0.2cm]
There can also be \el{CuePoint}s for audio tracks. In that case, as every
frame will be a keyframe, the number of \el{CuePoint}s only depends on the
muxing application. Predicting the overhead requires to know its behaviour.
\newpage
\section{Links}
Matroska pages / software: 
\begin{verbatim}
http://www.matroska.org
http://haali.cs.msu.ru/mkv/
http://www.alexander-noe.com/
http://de.wikipedia.org/wiki/Matroska
http://www.matroska.info/
http://ld-anime.faireal.net/guide/jargon.matroska-en
\end{verbatim}
\end{document}